# Modeling as a Process {#process}

```{r, include=FALSE, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, 
                      fig.height=3, fig.width=5,  
                      cache=TRUE, fig.align = "center")

library(tidyverse)
library(tidymodels)
library(gghighlight)
library(schrute)
library(broom)
library(kableExtra)
#library(boot)
library(knitr)
library(NHANES)
library(skimr)
library(patchwork)
options(digits=3)
```


## Comparing Models^[Thanks to Mine Çentinkaya-Rundel and Julia Silge for the ideas and much of the code in this chapter.  Mine's course is at https://mine-cr.com/teaching/sta210/. Julia's blog is at https://juliasilge.com/blog/project-feederwatch/.]

So many models, so little time.  Understanding how to interpret a multiple linear regression model is only half of the modeling process.  In most real-life situations, there are many variables which can be used to predict or describe the response variable at hand.  But how to choose which combination or subset of variables is best?

Here, we'll walk through many of the big ideas surrounding the modeling building process.  In the next chapter we will consider the technical ideas behind statistical inference for modeling building.  But even when using formal inference, the ideas here should always inform the larger process and analysis conclusions.

[Leo Breiman](https://en.wikipedia.org/wiki/Leo_Breiman) was among the giants in machine learning who helped to bridge ideas in statistics and computer science.  Trained as a statistician, he spent his career at the University of California, Berkeley where he developed Classification and Regression Trees (CART), bagging, and Random Forests.  

Among his important insights was an idea that there are [two cultures](https://projecteuclid.org/journals/statistical-science/volume-16/issue-3/Statistical-Modeling--The-Two-Cultures-with-comments-and-a/10.1214/ss/1009213726.full) which can motivate (linear) modeling:

> Think of the data as being generated by a black box in which a vector of input variables x (independent variables) go in one side, and on the other side the response variables y come out. Inside the black box, nature functions to associate the predictor variables with the response variables.

```{r fig.align='center', echo=FALSE}
knitr::include_graphics("figs/blackbox.png")
```

> 1. Data Modeling: The analysis in this culture starts with assuming a stochastic data model for the inside of the black box...The values of the parameters are estimated from the data and the model then used for information and/or prediction

> 2. Algorithmic Modeling: The analysis in this culture considers the inside of the box complex and unknown. [The] approach is to find a function f(x) — an algorithm that operates on x to predict the responses y.

Here in Chapter \@ref(process), the focus will be on algorithmic modeling and developing models which are optimally predictive of the response variable at hand.

**Spoiler:**

- In Chapter \@ref(logreg), the model building uses hypothesis testing and p-values.
- In Chapter \@ref(process), the model building uses outside information and independent assessment.

There isn't a right way to model.  In fact, good data analysis is **hard**.  You are building a tool box.  Make sure to notice that not every tool is the same, and you have more than just one hammer to use.  Sometimes the tools can work together to form even better models.

#### Worth a comment {-}

Notice that the R code has gotten more interesting now.  How fun!! The R code will help the process!  The R package **tidymodels** includes tools to facilitate, in particular, feature engineering and cross validation.


### Bias-variance trade-off {-}

**Excellent resource**

for explaining the bias-variance trade-off:  http://scott.fortmann-roe.com/docs/BiasVariance.html

* **Variance** refers to the amount by which $\hat{f}$ would change if we estimated it using a different training set.  Generally, the closer the model fits the data, the more variable it will be (it'll be different for each data set!).  A model with many many explanatory variables will often fit the data too closely.

* **Bias** refers to the error that is introduced by approximating the "truth" by a model which is too simple. For example, we often use linear models to describe complex relationships, but it is unlikely that any real life situation actually has a *true* linear model.  However, if the true relationship is close to linear, then the linear model will have a low bias.

Generally, the simpler the model, the lower the variance.  The more complicated the model, the lower the bias.  In this class, cross validation will be used to assess model fit using metrics like accuracy and Receiver Operating Characteristic (ROC) curves.


\begin{align}
\mbox{prediction error } = \mbox{ irreducible error } + \mbox{ bias } + \mbox{ variance}
\end{align}

* **irreducible error**  The irreducible error is the natural variability that comes with observations.  No matter how good the model is, we will never be able to predict perfectly.
* **bias**  The bias of the model represents the difference between the true model and a model which is too simple.  That is, the more complicated the model (e.g., the more variables), the closer the points are to the prediction.  As the model gets more complicated (e.g., as variables are added), the bias goes down.
* **variance**  The variance represents the variability of the model from sample to sample.  That is, a simple model (very few variables) would not change a lot from sample to sample.  The variance decreases as the model becomes more simple (e.g., variables are removed).


Note the bias-variance trade-off.  We want our prediction error to be small, so we choose a model that is medium with respect to both bias and variance.  We cannot control the irreducible error.

```{r fig.cap = "Test and training error as a function of model complexity.  Note that the error goes down monotonically only for the training data.  Be careful not to overfit!!  [@ESL]", out.width='100%', fig.align='center', echo=FALSE}
knitr::include_graphics("figs/varbias.png")
```

In the linear regression case, the following plots describe the bias-variance tradeoff.  In our setting, the models change due to the number of variables included in the model (which is difficult to draw because those models exist in dozens of dimensions).

```{r echo = FALSE, fig.width = 7}
library(patchwork)
explanatory <- runif(100, 1, 10)
response <- 12 + 15*explanatory^2 + rnorm(100,0,100)

data <- data.frame(explanatory, response)

p1 <- data %>%
  ggplot(aes(x = explanatory, y = response)) + 
  geom_point(size = 0.7) + 
  geom_smooth(method = "lm", se = FALSE) + 
  ggtitle("underfit: \nhigh bias, low var")

p2 <- data %>%
  ggplot(aes(x = explanatory, y = response)) + 
  geom_point(size = 0.7) + 
  geom_smooth(method = "loess", se = FALSE) + 
  ggtitle("good fit: \nlow bias, low var")

p3 <- data %>%
  ggplot(aes(x = explanatory, y = response)) + 
  geom_point(size = 0.7) + 
  geom_smooth(method = "loess", se = FALSE, span = 0.1) + 
  ggtitle("overfit: \nlow bias, high var")

p1 + p2 + p3
```



## Modeling Squirrel Activity

For the example used to consider feature engineering and cross validation, the data come from <a href = "https://feederwatch.org/explore/raw-dataset-requests/" target = "_blank">Project FeederWatch</a>#TidyTuesday dataset on Project FeederWatch, a citizen science project for bird science, by way of <a href = "https://github.com/rfordatascience/tidytuesday/tree/master/data/2023/2023-01-10" target = "_blank">TidyTuesday</a>.  Many of the ideas below are due to <a href = "https://juliasilge.com/blog/project-feederwatch/" target = "_blank">screencasts by Julia Silge</a>.


> Can the characteristics of the bird feeder site like the surrounding yard and habitat predict whether a bird feeder site will be used by squirrels?

Instead of jumping into the predictions immediately, let's look at the data itself.  What wrangling can we do to the data in order to take advantage of all the information in the variables?  We'd also like to make the model accurate and easy to communicate.

```{r}
site_data <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-01-10/PFW_count_site_data_public_2021.csv') %>%
  mutate(squirrels = as.factor(ifelse(squirrels, "squirrels", "no squirrels")))

glimpse(site_data)
```

It is a huge dataset, although it has a lot of missing information.

```{r}
site_data %>%
  count(squirrels)
```
How are other characteristics of these sites related to the presence of squirrels?

```{r}
site_data %>%
  filter(!is.na(squirrels)) %>%
  group_by(squirrels) %>%
  summarise(nearby_feeders = mean(nearby_feeders, na.rm = TRUE))
```
What about some of the other variables like those describing the habitat?

```{r}
site_data %>%
  filter(!is.na(squirrels)) %>%
  group_by(squirrels) %>%
  summarise(across(contains("hab"), mean, na.rm = TRUE)) %>%
  pivot_longer(contains("hab")) %>%
  mutate(name = str_remove(name, "hab_")) %>%
  ggplot(aes(value, fct_reorder(name, value), fill = squirrels)) +
  geom_col(alpha = 0.8, position = "dodge") +
  scale_x_continuous(labels = scales::percent) +
  labs(x = "% of locations", y = NULL, fill = NULL)
```


## Building a Model

If the idea is to build a model which can predict squirrel activity, we need to have a way to see how we did (at the end).  Indeed, it is important for us to put some data in our pocket (it will be called the "test" data) which doesn't see any of the modeling process.  We'll use the test data at the end to assess whether or not our predictions are any good.

#### Create the dataset

There is a little bit of work to do to use only the observations that recodered whether or not there was a squirrel and to remove a few variables which are not of interest.

```{r}
library(tidymodels)

site_data <- site_data %>%
  filter(!is.na(squirrels)) %>%
  select(where(~!all(is.na(.x)))) %>%
  select(-loc_id, -proj_period_id, -fed_yr_round) %>%
  select(squirrels, everything()) 
```


#### Train / test {-}

**Step 1:** Create an initial split:

```{r}
set.seed(470)
feeder_split <- site_data %>%
  initial_split(strata = squirrels) # prop = 3/4 in each group, by default
```

**Step 2:** Save training data

```{r}
feeder_train <- training(feeder_split)
dim(feeder_train)
```

**Step 3:** Save testing data

```{r}
feeder_test  <- testing(feeder_split)
dim(feeder_test)
```

#### Using the training data {-}

```{r}
feeder_train
```


### Modeling workflow

Ideally, the feature engineering / variable selection happens as part of the workflow.  That is, part of the modeling process.  That way, when the training data is used to fit the model, feature engineering happens.  When the test data is used to come up with predictions, feature engineering also happens.

-   Create a **recipe** for feature engineering steps to be applied to the training data

-   Fit the model to the training data after these steps have been applied

-   Use the model estimates from the training data, predict outcomes for the test data

-   Evaluate the performance of the model on the test data


The process is synthesized in the following graphic from a course at Johns Hopkins, <a href = "https://jhudatascience.org/tidyversecourse/" target = "_blank">Tidyverse Skills for Data Science</a>.


```{r echo = FALSE, out.width = "80%", fig.cap = "Image credit: Wright et al., Chapter 5 of Tidyverse Skills for Data Science https://jhudatascience.org/tidyversecourse/"}
knitr::include_graphics("figs/tidypackages.png")
```

### Specifying a model

Instead of using the `glm()` command, we're going to use the **tidymodels** framework to specify a model.  In Math 150 we will *always* use "glm" as the engine, but if you take other applied statistics classes, you'll use different model specifications with the same feature engineering and modeling fitting steps.

Note that (above) I pulled in all of the relevant functions from the package using `library(tidymodels)`.

```{r}
feeder_spec <- logistic_reg() %>%
  set_engine("glm") 

feeder_spec
```

### Building a recipe

The steps in building a recipe are done sequentially so that the format of each variable is as desired for the model.  As seen in Section (\@ref{sec:wflow}), the recipe steps can happen in sequence using the pipe (`%>%`) function.

However, when you work with a single pipeline, the recipe effects on the data aren't seen, which can be unsettling.  You can look at what will happen when you ultimately apply the recipe to your data by using the functions `prep()` and `bake()`.

**Note:**  Using `prep()` and `bake()` are shown here for demonstrative purposes.  They do not need to be a part of your pipeline.  I do find them assuring, however, so that I can see the effects of the recipe steps as the recipe is built.

#### Initiate a recipe {-}

```{r}
feeder_rec <- recipe(
  squirrels ~ .,    # formula
  data = feeder_train # data for cataloging names and types of variables
  )

feeder_rec
```


#### Remove zero variance predictors {-}

Remove all predictors that contain only a single value.  "zero variance" means that there is no variability in the entire column, literally every value is the same.  Those variables won't ever help with prediction.

> `step_impute_mean()` fills in all the missing values using the average of that variable.
> `step_nzv()` creates a specification of a recipe step that will remove variables that contain only a single value.

```{r}
feeder_rec <- feeder_rec %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())

feeder_rec
```

```{r}
feeder_rec_trained <- prep(feeder_rec)

bake(feeder_rec_trained, feeder_train) %>%
  glimpse
```

**`step_` functions**

For more information: https://recipes.tidymodels.org/reference/index.html

```{r}
ls(pattern = '^step_', env = as.environment('package:recipes'))
```

### Building workflows


**Workflows** bring together models and recipes so that they can be easily applied to both the training and test data.


#### Specify model {-}

```{r}
feeder_spec <- logistic_reg() %>%
  set_engine("glm")

feeder_spec
```

**The workflow:**  Notice that the two important parts to the workflows are the model specification and the feature engineering recipe information.

```{r}
feeder_wflow <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec)

feeder_wflow
```


#### Fit model to training data {-}

With the workflow in hand, the model can now be fit to the training data.  Although, wow... there are *so many predictors*!

```{r}
feeder_fit <- feeder_wflow %>%
  fit(data = feeder_train)

feeder_fit %>% tidy() %>% print(n = 21)
```


### Evaluate the model

#### Predictions for training data {-}

#### Model assessment {-}

```{r}
feeder_train_pred <- predict(feeder_fit, feeder_train, type = "prob") %>%
  mutate(.pred_class = as.factor(ifelse(.pred_squirrels >=0.5,
                                        "squirrels", "no squirrels"))) %>%
  bind_cols(feeder_train %>% select(squirrels))

feeder_train_pred %>% select(squirrels, .pred_class) %>% table()

roc_auc(feeder_train_pred, truth = squirrels, estimate = `.pred_no squirrels`)

accuracy(feeder_train_pred, truth = squirrels, estimate = .pred_class)

sensitivity(feeder_train_pred, truth = squirrels, estimate = .pred_class)

specificity(feeder_train_pred, truth = squirrels, estimate = .pred_class)

feeder_train_pred %>%
  ggplot() + 
  plotROC::geom_roc(aes(m = .pred_squirrels, d = squirrels)) + 
  geom_abline(intercept = 0, slope = 1, color = "blue")
```

Wow, that model does **TERRIBLY** at predicting when there are no squirrels.  Yikes!  (The underlying problem is all about the imbalance in the dataset.)

But, really...

*who cares about predictions on **training** data?*

### Predictions for testing data {-}

```{r}
feeder_test_pred <- predict(feeder_fit, feeder_test) %>%
  bind_cols(feeder_test %>% select(squirrels))

feeder_test_pred %>% table()
```


```{r}
feeder_test_pred <- predict(feeder_fit, feeder_test, type = "prob") %>%
  mutate(.pred_class = as.factor(ifelse(.pred_squirrels >=0.5,
                                        "squirrels", "no squirrels"))) %>%
  bind_cols(feeder_test %>% select(squirrels))

feeder_test_pred %>% select(squirrels, .pred_class) %>% table()

roc_auc(feeder_test_pred, truth = squirrels, estimate = `.pred_no squirrels`)

accuracy(feeder_test_pred, truth = squirrels, estimate = .pred_class)

sensitivity(feeder_test_pred, truth = squirrels, estimate = .pred_class)

specificity(feeder_test_pred, truth = squirrels, estimate = .pred_class)

feeder_test_pred %>%
  ggplot() + 
  plotROC::geom_roc(aes(m = .pred_squirrels, d = squirrels)) + 
  geom_abline(intercept = 0, slope = 1, color = "blue")
```


#### Evaluating performance on training data {-}

-   The training set does not have the capacity to be a good arbiter of performance.

-   It is not an independent piece of information; predicting the training set can only reflect what the model already knows.

-   Suppose you give a class a test, then give them the answers, then provide the same test.
    The student scores on the second test do not accurately reflect what they know about the subject; these scores would probably be higher than their results on the first test.


## Cross Validation

Before reading the notes, look through <a href = "http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" target = "_blank">this great visualization</a>.  Don't worry about building the model (classification trees are not a topic for class), but check out the end where they talk about predicting on test and training data.

In order to motivate cross validation, let's set up the scenario for when we need cross validation.  Recall that we use the test data to assess how the model does.  But we haven't yet thought about how to use the data to **build** a particular model.

For example, let's set up a scenario to compare two different models to predict whether or not there are squirrels.  The first model removes the information about the habitat and about the trees and shrubs, but it is otherwise similar to the model above.  The second model does use the habitat + trees + shrubs information, but it removes the information about feeding the birds.

**Model 1:**
```{r}
feeder_rec1 <- recipe(squirrels ~ ., data = feeder_train) %>%
  # delete the habitat variables
  step_rm(contains("hab")) %>%
  # delete the tree/shrub info
  step_rm(contains("atleast")) %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())
```


```{r}
prep(feeder_rec1) %>%
bake(feeder_train) %>%
  glimpse()
```


**Model 2:**
```{r}
feeder_rec2 <- recipe(squirrels ~ ., data = feeder_train) %>%
  # delete the variables on when the birds were fed
  step_rm(contains("fed")) %>%
  # delete the variables about the bird feeders
  step_rm(contains("feed")) %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())
```


```{r}
prep(feeder_rec2) %>%
bake(feeder_train) %>%
  glimpse()
```


#### Creating workflows {-}

Using each of the separate recipes, different workflows are set up:

**Model 1:**
```{r}
feeder_wflow1 <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec1)

feeder_wflow1
```

**Model 2:**
```{r}
feeder_wflow2 <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec2) 

feeder_wflow2
```



#### Fit the models to the training data {-}


**WAIT**, not so fast!  

```{r echo = FALSE, eval = FALSE}
feeder_wflow1 %>%
  fit(data = feeder_train) %>%
  tidy()
```

```{r echo = FALSE, eval = FALSE}
feeder_wflow2 %>%
  fit(data = feeder_train) %>%
  tidy()
```

#### Implementing Cross Validation {-}


```{r fig.cap = "[@flach12]", out.width='100%', fig.align='center', echo=FALSE}
knitr::include_graphics("figs/overfitting.jpg")
```

Cross validation is typically used in two ways.  

1. To assess a model's accuracy (*model assessment*).  
2. To build a model (*model selection*).

### Different ways to CV

Suppose that we build a classifier on a given data set.  We'd like to know how well the model classifies observations, but if we test on the samples at hand, the error rate will be much lower than the model's inherent accuracy rate.  Instead, we'd like to predict *new* observations that were not used to create the model.  There are various ways of creating *test* or *validation* sets of data:

* one training set, one test set  [two drawbacks:  estimate of error is highly  variable because it depends on which points go into the training set; and because the training data set is smaller than the full data set, the error rate is biased in such a way that it overestimates the actual error rate of the modeling technique.]

* leave one out cross validation (LOOCV)
1. remove one observation
2. build the model using the remaining n-1 points
3. predict class membership for the observation which was removed
4. repeat by removing each observation one at a time

* $V$-fold cross validation ($V$-fold CV)
    * like LOOCV except that the algorithm is run $V$ times on each group (of approximately equal size) from a partition of the data set.]
    * LOOCV is a special case of $V$-fold CV with $V=n$
    * advantage of $V$-fold is computational
    * $V$-fold often has a better bias-variance trade-off [bias is lower with LOOCV.  however, because LOOCV predicts $n$ observations from $n$ models which are basically the same, the variability will be higher (i.e., based on the $n$ data values).  with $V$-fold, prediction is on $n$ values from $V$ models which are much less correlated.  the effect is to average out the predicted values in such a way that there will be less variability from data set to data set.]


#### CV for **Model assessment** 10-fold {-}

1. assume variables are set
2. remove 10% of the data
3. build the model using the remaining 90%
4. predict response for the 10% of the observations which were removed
5. repeat by removing each decile one at a time
6. a good measure of the model's ability to predict is the error rate associated with the predictions on the data which have been independently predicted


#### CV for **Model selection** 10-fold {-}

1. set the variables
2. build the model using the variables set above:
    a. remove 10% of the data
    b. build the model using the remaining 90%
    c. predict response for the 10% of the observations which were removed
    d. repeat by removing each decile one at a time
3. measure the CV prediction error for the $k$ value at hand
4. repeat steps 1-3 and choose the variables for which the prediction error is lowest

```{r fig.cap = "4-fold CV is depicted.  Notice that the holdout group is never used as part of the coefficient estimation process.", out.width = "90%", fig.align='center', echo=FALSE}
knitr::include_graphics("figs/CV.png")
```

```{r eval = FALSE, echo = FALSE}
#### CV for **Model assessment and selection** 10-fold {-}

To do both, one approach is to use test/training data *and* CV in order to both model assessment and selection.   Note that CV could be used in both steps, but the algorithm is slightly more complicated.  The process is described here with $k$-Nearest Neighbors classification in order to describe choosing the value of $k$ which will be modeled.

1. split the data into training and test observations
2. set $k$ in $k$-NN
3. build the model using the $k$ value set above on *only the training data*:
    a. remove 10% of the training data
    b. build the model using the remaining 90% of the training data
    c. predict class membership / continuous response for the 10% of the training observations which were removed
    d. repeat by removing each decile one at a time from the training data
4. measure the CV prediction error for the $k$ value at hand on the training data
5. repeat steps 2-4 and choose the $k$ for which the prediction error is lowest for the training data
6. using the $k$ value given in step 5, assess the prediction error on the test data
```

Once the model has been built (i.e., the variables have been selected), we can come up with a good estimate of the accuracy in the wild by applying the model to the test data.

```{r fig.cap = "Nested cross-validation: two cross-validation loops are run one inside the other.  [@CVpaper]", out.width='100%', fig.align='center', echo=FALSE}
knitr::include_graphics("figs/CV.jpg")
```


```{r eval = FALSE, echo = FALSE}
#### Thoughts on CV {-}

$v$-fold cross validation ($v$-fold CV)  [note:  the $v$ in $v$-fold is different from the $v$ in the model building algorithms denoting the number of variables.]

* like LOOCV except that the algorithm is run $v$ times (instead of $n$ times) on each of $v$ groups (of approximately equal size) from a partition of the data set.  (LOOCV is a special case of $v$-fold CV with $v=n$)
* advantage of $v$-fold is computational 
* $v$-fold often has a better bias-variance trade-off [bias is lower with LOOCV.  however, because LOOCV predicts $n$ observations from $n$ models which are basically the same, the variability will be higher (i.e., based on the $n$ data values).  with $v$-fold, prediction is on $n$ values from $v$ models which are much less correlated.  the effect is to average out the predicted values in such a way that there will be less variability from data set to data set.]
```

### Fit the models using cross validation

#### "Spending" the data {-}

-   We have already established that the idea of data spending where the test set was recommended for obtaining an unbiased estimate of performance.
-   However, we need to decide which model to choose *before using the test set*.
-   Typically we can't decide on *which* final model to take to the test set without making model assessments.
-   Remedy: Cross validation to make model assessments on training data in a way that can generalize to new data.

#### CV for model assessment {-}

**Cross validation is only conducted on the training set**.
The test set is not involved.
For each iteration, the data are partitioned into two subsamples:

-   The model is fit with the **analysis set**.
-   The model is evaluated with the **assessment set**.

```{r fig.cap = "Repeated samples are taken from the training data, and with each resample some of the observations are used to build a model and some observations are used to estimate the performance. Source: [@tidymodelingR]", out.width='100%', fig.align='center', echo=FALSE, eval = FALSE}
knitr::include_graphics("figs/resampling.svg")


Aside: the "re" in "resamples" is for repeated samples.  Not to be confused where repeated samples are taken in bootstrapping with replacement.  In cross validation, the repeated samples are taken **without** replacement.
```

#### Cross validation {-}

More specifically, **v-fold cross validation**:

-   Randomly split the **training** **data** into v partitions
-   Use 1 partition for assessment, and the remaining v-1 partitions for analysis
-   Repeat v times, updating which partition is used for assessment each time

Let's give an example where `v = 3`...

#### Cross validation, step 1 {-}

Consider the example below where the **training** **data** are randomly split into 3 partitions:

```{r fig.cap = "Splitting the data into a partition of v=3 groups. Source: [@tidymodelingR]", fig.alt = "Thirty observations are seen where three colors are used to demonstrate that the observations can be partitioned into three groups.", out.width='100%', fig.align='center', echo=FALSE}
knitr::include_graphics("figs/three-CV.svg")
```


```{r}
set.seed(4747)
folds <- vfold_cv(feeder_train, v = 3, strata = squirrels)
folds
```

Note that the three repeated samples ("resamples") are taken without replacement from the original dataset.

#### Cross validation, steps 2 and 3 {-}

-   Use 1 partition for assessment, and the remaining v-1 partitions for analysis
-   Repeat v times, updating which partition is used for assessment each time

```{r fig.cap = "With the data split into three groups, we can see how 2/3 of the observations are used to fit the model and 1/3 of the observations are used to estimate the performance of the model. Source: [@tidymodelingR]", fig.alt = "Three iterations of model fitting are shown, each time using only 2/3 of the observations.  The remaining 1/3 of the observations are used to estimate the performance of the model.", out.width='100%', fig.align='center', echo=FALSE}
knitr::include_graphics("figs/three-CV-iter.svg")
```

#### Fit CV folds {-}

After the data have been split into v (here 3) resamples, they can each be fit to the two models of interest.

Let's also make sure that we can get back all of the metrics we are interested in:

```{r}
metrics_interest <- metric_set(accuracy, roc_auc, 
                              sensitivity, specificity)
```


> sensitivty = number of squirrels that are accurately predicted to be squirrels (true positive rate)

> specificity = number of non-squirrels that are accurately predicted to be non-squirrels (true negative rate)

```{r}
feeder_train %>% select(squirrels) %>% table()
```


**Model 1:**
```{r}
feeder_fit_rs1 <- feeder_wflow1 %>%
  fit_resamples(resamples = folds,
                metrics = metrics_interest,
                control = control_resamples(save_pred = TRUE))

feeder_fit_rs1
```


**Model 2:**
```{r}
feeder_fit_rs2 <- feeder_wflow2 %>%
  fit_resamples(resamples = folds,
                metrics = metrics_interest,
                control = control_resamples(save_pred = TRUE))

feeder_fit_rs2
```

#### Cross validation, now what? {-}

-   We've fit a bunch of models
-   Now it's time to use them to collect metrics (e.g., accuracy or AUC) on each model and use them to evaluate model fit and how it varies across folds

#### Collect CV metrics {-}

**Model 1:**
```{r}
collect_metrics(feeder_fit_rs1)
```

```{r}
feeder_fit_rs1 %>% augment() %>%
  mutate(squirrels = squirrels) %>%
  select(squirrels, .pred_class) %>%
  yardstick::conf_mat(squirrels, .pred_class) %>%
  autoplot(type = "heatmap") + 
  scale_fill_gradient(low="#D6EAF8", high="#2E86C1") 
```

**Model 2:**
```{r}
collect_metrics(feeder_fit_rs2)
```

```{r}
feeder_fit_rs2 %>% augment() %>%
  mutate(squirrels = squirrels) %>%
  select(squirrels, .pred_class) %>%
  yardstick::conf_mat(squirrels, .pred_class) %>%
  autoplot(type = "heatmap") + 
  scale_fill_gradient(low="#D6EAF8", high="#2E86C1") 

```

#### Deeper look into CV metrics {-}

**Model 1:**
```{r}
cv_metrics1 <- collect_metrics(feeder_fit_rs1, summarize = FALSE) 

cv_metrics1
```

**Model 2:**
```{r}
cv_metrics2 <- collect_metrics(feeder_fit_rs2, summarize = FALSE) 

cv_metrics2
```

#### Better tabulation of CV metrics {-}

**Model 1:**
```{r echo = FALSE}
cv_metrics1 %>%
  mutate(.estimate = round(.estimate, 3)) %>%
  pivot_wider(id_cols = id, names_from = .metric, values_from = .estimate) 
```

**Model 2:**
```{r echo = FALSE}
cv_metrics2 %>%
  mutate(.estimate = round(.estimate, 3)) %>%
  pivot_wider(id_cols = id, names_from = .metric, values_from = .estimate) 
```



**Conclusions:**

-  The logistic model is **terrible** at predicting when there are no squirrels (this is partly due to imbalanced data).
-  It seems as though the linear model which includes the information about the habitat and the trees does a slightly better job than the linear model that includes the information about when and how the birds are fed.

#### Cross validation jargon {-}

-   Referred to as v-fold or k-fold cross validation
-   Also commonly abbreviated as CV

#### Cross validation, redux {-}

-   To illustrate how CV works, we used `v = 3`:

  -   Analysis sets are 2/3 of the training set
  -   Each assessment set is a distinct 1/3
  -   The final resampling estimate of performance averages each of the 3 replicates

-   It was useful for illustrative purposes, but `v = 3` is a poor choice in practice

-   Values of `v` are most often 5 or 10; we generally prefer 10-fold cross-validation as a default

## Final model assessment

Now that Model 2 has been chosen as the better model, the test data is **finally** brought in to measure how well Model 2 will predict data in the wild.

**Model 2:**

n.b. For whatever reason, `collect_metrics()` only works when multiple models have been run.  When a single model is run, the metrics need to be evaluated individually.

```{r}
feeder_preds2 <- feeder_wflow2 %>%
  fit(data = feeder_train) %>%
  predict(feeder_test, type = "prob") %>% 
  mutate(.pred_class = as.factor(ifelse(.pred_squirrels >=0.5,
                              "squirrels", "no squirrels"))) %>%
  bind_cols(feeder_test %>% select(squirrels)) 

feeder_preds2 %>%
  yardstick::roc_auc(truth = squirrels,
                     estimate = `.pred_no squirrels`)

feeder_preds2 %>%
  yardstick::accuracy(truth = squirrels,
                      estimate = .pred_class)

feeder_preds2 %>%
  yardstick::sensitivity(truth = squirrels, estimate = .pred_class)


feeder_preds2 %>%
  yardstick::specificity(truth = squirrels, estimate = .pred_class)

```


  

## R: Full pipeline with CV + assessment

The following example uses **tidymodels** modeling to work through different aspects of the logistic regression model.  Using the same example as above, the process has been synthesized into the essential aspects / code.

### The data

Break the data into test and training sets.

```{r}
set.seed(470)
feeder_split <- site_data %>%
  initial_split(strata = squirrels) # prop = 3/4 in each group, by default
feeder_train <- training(feeder_split)
feeder_test <- testing(feeder_split)
```


### The model / enigne

Tell the computer to run logistic regression using the `glm()` function.

```{r}
feeder_spec <- logistic_reg() %>%
  set_engine("glm")
```

### The recipe(s)

Set the variables of interest (in the formula) and perform any necessary feature engineering.

```{r}
feeder_rec <- recipe(
  squirrels ~ .,    # formula
  data = feeder_train # data for cataloging names and types of variables
  ) %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())

feeder_rec1 <- recipe(squirrels ~ ., data = feeder_train) %>%
  # delete the habitat variables
  step_rm(contains("hab")) %>%
  # delete the tree/shrub info
  step_rm(contains("atleast")) %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())


feeder_rec2 <- recipe(squirrels ~ ., data = feeder_train) %>%
  # delete the variables on when the birds were fed
  step_rm(contains("fed")) %>%
  # delete the variables about the bird feeders
  step_rm(contains("feed")) %>%
  step_impute_mean(all_numeric_predictors()) %>%
  step_nzv(all_numeric_predictors())
```


### The workflow(s)

```{r}
feeder_wflow <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec)

feeder_wflow1 <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec1)

feeder_wflow2 <- workflow() %>%
  add_model(feeder_spec) %>%
  add_recipe(feeder_rec2)
```


### Choice:  fit the model? cross validate to decide between models?

#### Fit the model {-}

```{r}
feeder_fit <- feeder_wflow %>%
  fit(data = feeder_train)
```

The fit object is the same as the output of `glm()` that you are used to working with:
```{r}
feeder_fit %>% tidy()

feeder_fit %>% glance()
```

#### Cross validate to choose between models {-}

If cross validating, the model needs to be fit separately on each one of the hold out folds of the CV model.  Here, `v=10` is used, different from above where `v=3` was used to simplify the explanation.  Typically, the number of folds is 5 or 10.

Note that the objects are now similar to what you've worked with previously (output of `glm()`), but they contain a separate fit (i.e., linear model) for each of the CV folds.

```{r}
set.seed(47)
folds <- vfold_cv(feeder_train, v = 10)

feeder_fit_rs1 <- feeder_wflow1 %>%
  fit_resamples(folds)

feeder_fit_rs2 <- feeder_wflow2 %>%
  fit_resamples(folds)
```

### Assess the fit

#### On the test data {-}

Note that we should only assess the fit to the test data if we are done with the model building process and we've chosen the model we want to move forward with.

Accuracy, AUC, sensitivity, and specificity are all calculated.

If the first few lines don't make sense, run the pieces.  That is, run `predict(feeder_fit, feeder_test)` and then run `feeder_test %>% select(imdb_rating, title)` and then think about what it would mean to **bind** those columns together.

```{r}
feeder_test_pred <- predict(feeder_fit, feeder_test, type = "prob") %>%
  mutate(.pred_class = as.factor(ifelse(.pred_squirrels >=0.5,
                                        "squirrels", "no squirrels"))) %>%
  bind_cols(feeder_test %>% select(squirrels))

roc_auc(feeder_test_pred, truth = squirrels, estimate = `.pred_no squirrels`)

accuracy(feeder_test_pred, truth = squirrels, estimate = .pred_class)

sensitivity(feeder_test_pred, truth = squirrels, estimate = .pred_class)

specificity(feeder_test_pred, truth = squirrels, estimate = .pred_class)

feeder_test_pred %>%
  ggplot() + 
  plotROC::geom_roc(aes(m = .pred_squirrels, d = squirrels)) + 
  geom_abline(intercept = 0, slope = 1, color = "blue")
```

#### On the CV folds {-}

Note the difference in the information.  If you want the values per fold, don't summarize.  If you want the overall information, do summarize.

```{r}
feeder_fit_rs1 %>% collect_metrics()
feeder_fit_rs2 %>% collect_metrics()

feeder_fit_rs1 %>% collect_metrics(summarize = FALSE)
feeder_fit_rs2 %>% collect_metrics(summarize = FALSE)
```

Note that the variables in Model 2 perform better using cross validation than the variables in Model 1, we choose Model 2 to report out:

```{r}
feeder_test_pred_2 <- feeder_wflow2 %>%
  fit(feeder_train) %>%
  predict(feeder_test, type = "prob") %>%
  mutate(.pred_class = as.factor(ifelse(.pred_squirrels >=0.5,
                                        "squirrels", "no squirrels"))) %>%
  bind_cols(feeder_test %>% select(squirrels))

roc_auc(feeder_test_pred_2, truth = squirrels, estimate = `.pred_no squirrels`)

accuracy(feeder_test_pred_2, truth = squirrels, estimate = .pred_class)

sensitivity(feeder_test_pred_2, truth = squirrels, estimate = .pred_class)

specificity(feeder_test_pred_2, truth = squirrels, estimate = .pred_class)
```

```{r}
feeder_test_pred_2 %>%
  ggplot() + 
  plotROC::geom_roc(aes(m = .pred_squirrels, d = squirrels)) + 
  geom_abline(intercept = 0, slope = 1, color = "blue")
```


