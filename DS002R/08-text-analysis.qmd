# Text analysis {#sec-text-analysis}


```{r}
#| include: false

source("_common.R")
fontawesome::fa_html_dependency()
```




## Variable Types

Some new variable types: 

* character strings
* factor variables
* dates
* numeric
* logical

A variable's type determines the values that the variable can take on and the operations that can be performed on it.  Specifying variable types ensures the dataset's integrity and increases performance. 



## Character strings

When working with character strings, we might want to detect, replace, or extract certain patterns. 

Strings are objects of the **character** class (abbreviated as `<chr>` in tibbles). When you print out strings, they display with double quotes:

```{r}
some_string <- "banana"
some_string
```

### Creating strings

Creating strings by hand is useful for testing out regular expressions.

To create a string, type any text in either double quotes `"` or single quotes `'`. Using double or single quotes doesn't matter unless your string itself has single or double quotes.

```{r}
string1 <- "This is a string"
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'

string1
string2
```

### Working with `str_*()` functions

#### `str_view()`

We can view these strings more "naturally" (without the opening and closing quotes) `with str_view()`:

```{r}
str_view(string1)
str_view(string2)
```

#### `str_c`

Similar to `paste()` (gluing strings together), but works well in a tidy pipeline.

```{r}
df <- tibble(name = c("Flora", "David", "Terra", NA))
df |> mutate(greeting = str_c("Hi ", name, "!"))
```

#### `str_sub()`

`str_sub(string, start, end)` will extract parts of a `string` where `start` and `end` are the positions where the substring starts ane ends.

```{r}
fruits <- c("Apple", "Banana", "Pear")
str_sub(fruits, 1, 3)
str_sub(fruits, -3, -1)
```


Won't fail if the string is too short.

```{r}
str_sub(fruits, 1, 5)
```

#### `str_sub()` in a pipeline

We can use the `str_*()` functions inside the `mutate()` function.

```{r}
#| echo: false
titanic <- Titanic |> 
  as.data.frame()
```

```{r}
titanic |> 
  mutate(class1 = str_sub(Class, 1, 1))
```


#### `str_replace*()`

`str_replace()` replaces the first match of a pattern. `str_replace_all()` replaces all the matches of a pattern.

```{r}
fruits
str_replace(fruits, "a", "x")
str_replace_all(fruits, "a", "x")
```

#### `str_detect()` 


```{r}
str_detect(fruits, "a")
```


`str_detect()` can be seamlessly used in a `filter()` pipeline.

::: {.panel-tabset}

## original data

```{r}
starwars |> 
  select(name, films) |> 
  str() 
```

## filtered data

```{r}
starwars |> 
  filter(str_detect(films, "Empire")) |> 
  select(name, films) |> 
  str()
```
:::

#### **stringr** functions

The **stringr** package within tidyverse contains lots of functions to help process strings. Letting x be a string variable...

```{r}
#| echo: false

tribble(
  ~`str function`, ~arguments, ~returns,
"`str_replace()`",	"`x`, `pattern`, `replacement`",	"a modified string",
"`str_replace_all()`",	"`x`, `pattern`, `replacement`", "a modified string",
"`str_to_lower()`",	"`x`", "a modified string",
"`str_to_upper()`",	"`x`", "a modified string",
"`str_sub()`",	"`x`, `start`, `end`", "a modified string",
"`str_length()`",	"`x`", "a number",
"`str_detect()`",	"`x`, `pattern`",	"TRUE/FALSE") |> 
  kableExtra::kable()
```

Use the <a href = "https://rstudio.github.io/cheatsheets/html/strings.html" target = "_blank">**stringr** cheatsheet</a>. 

## Factor variables

Factor variables are a special type of character string.
The computer actually stores them as *integers* (?!?!!?) (abbreviated as `<fct>` in tibbles). 

* categorical variable
* represented in discrete levels

### Order matters

SurveyUSA poll from 2012 on views of the DREAM Act.

What is off about the data viz part of the report?

::: {.panel-tabset}

## Data
```{r}
glimpse(openintro::dream)
```

## Plot
```{r}
dream |> 
  ggplot(aes(x = ideology, fill = stance)) + 
  geom_bar()
```
:::

#### Change the order

We can fix the order of the `ideology` variable.

::: {.panel-tabset}

## Code
```{r}
#| eval: false
dream |> 
  mutate(ideology = fct_relevel(ideology, 
                                c("Liberal", "Moderate", "Conservative"))) |> 
  ggplot(aes(x = ideology, fill = stance)) + 
  geom_bar()
```

## Plot
```{r}
#| echo: false
dream |> 
  mutate(ideology = fct_relevel(ideology, 
                                c("Liberal", "Moderate", "Conservative"))) |> 
  ggplot(aes(x = ideology, fill = stance)) + 
  geom_bar()
```
:::

#### Factor *and* character variables


::: {.panel-tabset}

## Data
```{r}
starbucks |> 
  select(item, type, calories)
```

## Plot
```{r}
#| echo: false
starbucks |> 
  ggplot(aes(x = type, y = calories)) + 
  geom_point() + 
  labs(x = "type of food",
       y = "",
       title = "Calories for food items at Starbucks")
```
:::


### Reorder according to another variable

Lets say that we wanted to order the type of food item based on the average number of calories in that food.


::: {.panel-tabset}

## Code
```{r}
#| eval: false
starbucks |> 
  mutate(type = fct_reorder(type, calories, .fun = "mean", .desc = TRUE)) |> 
  ggplot(aes(x = type, y = calories)) + 
  geom_point() + 
  labs(x = "type of food",
       y = "",
       title = "Calories for food items at Starbucks")
 
```

## Plot
```{r}
#| echo: false
starbucks |> 
  mutate(type = fct_reorder(type, calories, .fun = "mean", .desc = TRUE)) |> 
  ggplot(aes(x = type, y = calories)) + 
  geom_point() + 
  labs(x = "type of food",
       y = "",
       title = "Calories for food items at Starbucks")
 
```

:::


#### **forcats** functions

The **forcats** package within tidyverse contains lots of functions to help process factor variables Use the <a href = "https://rstudio.github.io/cheatsheets/html/factors.html" target = "_blank">**forcats** cheatsheet</a>. We'll focus on the most common functions. 

* functions for changing the **order** of factor levels
    - `fct_relevel()` = *manually* reorder levels
    - `fct_reorder()` = reorder levels according to values of another *variable*
    - `fct_infreq()` = order levels from highest to lowest frequency
    - `fct_rev()` = reverse the current order

* functions for changing the **labels** or values of factor levels
    - `fct_recode()` = *manually* change levels
    - `fct_lump()` = *group together*  least common levels



## Time and Date


### Working with time and date

The (very well named) R package **lubridate** is used for wrangling time and date objects [@lubridate].  In particular, **lubridate** makes it very easy to work with days, times, and dates.  The base idea is to start with dates in a `ymd` (year month day) format and transform the information into whatever you want.   The <a href = "https://rstudio.github.io/cheatsheets/html/lubridate.html" target = "_blank">**lubridate** cheatsheet</a> provides many of the basic functionality.

Example from  https://lubridate.tidyverse.org/reference/lubridate-package.html

### If anyone drove a time machine, they would crash

The length of months and years change so often that doing arithmetic with them can be unintuitive. Consider a simple operation, January 31st + one month. Should the answer be:


1. February 31st (which doesn't exist)
2. March 4th (31 days after January 31), or
3. February 28th (assuming its not a leap year)

A basic property of arithmetic is that a + b - b = a. Only solution 1 obeys the mathematical property, but it is an invalid date. Wickham wants to  make **lubridate** as consistent as possible by invoking the following rule: if adding or subtracting a month or a year creates an invalid date, **lubridate** will return an NA. 

If you thought solution 2 or 3 was more useful, no problem. You can still get those results with clever arithmetic, or by using the special `%m+%` and `%m-%` operators. `%m+%` and `%m-%` automatically roll dates back to the last day of the month, should that be necessary.

### R examples

Some basics in **lubridate**.


```{r}
require(lubridate)
rightnow <- now()

day(rightnow)
week(rightnow)
month(rightnow, label=FALSE)
month(rightnow, label=TRUE)
year(rightnow)

minute(rightnow)
hour(rightnow)

yday(rightnow)
mday(rightnow)
wday(rightnow, label=FALSE)
wday(rightnow, label=TRUE)
```

But how do I create a date object?

```{r}
jan31 <- ymd("2021-01-31")
jan31 + months(0:11)

floor_date(jan31, "month") + months(0:11) + days(31)
jan31 + months(0:11) + days(31)

jan31 %m+% months(0:11)
```

NYC flights

```{r}
library(nycflights13)
names(flights)
flightsWK <- flights |> 
   mutate(ymdday = ymd(paste(year, month,day, sep="-"))) |>
   mutate(weekdy = wday(ymdday, label=TRUE), 
          whichweek = week(ymdday))

head(flightsWK)

flightsWK <- flights |> 
   mutate(ymdday = ymd(paste(year,"-", month,"-",day))) |>
   mutate(weekdy = wday(ymdday, label=TRUE), whichweek = week(ymdday))

flightsWK |> select(year, month, day, ymdday, weekdy, whichweek, dep_time, 
                     arr_time, air_time) |>  
   head()
```



## <i class="fas fa-lightbulb"></i> Reflection questions  



## <i class="fas fa-balance-scale"></i> Ethics considerations 



