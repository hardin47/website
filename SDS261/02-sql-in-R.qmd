# SQL in R {#sec-sql-R}

```{r}
#| include: false

source("_common.R")
library(tidyverse)
library(fontawesome)
fontawesome::fa_html_dependency()
```

There are three ways to engage with SQL using R.  We will discuss each of them in this chapter, and we will expand on the third method in what follows (comparing the RStudio IDE with other interfaces like DBeaver to run actual SQL code chunks).

1. Using the package **dbplyr** **R** will directly translate **dplyr** code into **SQL**.
2. Using the **DBI** package, we can send **SQL** queries through an `r` chunk.
3. Using a `sql` chunk, we can write actual **SQL** code inside a quarto document.



## Translating **dplyr** code into SQL {#sec-dplyr-seq}

Let's go back to the **airlines** database to try out some things that we already know how to do in **R**.  Recall that we need the **DBI** and **RMariaDB** packages to connect to **R**; we need the **dbplyr** package to translate **SQL** code into **R**.

```{r}
library(DBI)
library(RMariaDB)
library(dbplyr)

con <- DBI::dbConnect(
  RMariaDB::MariaDB(),
  dbname = "airlines",
  host = "mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com",
  user = "mdsr_public",
  password = "ImhsmflMDSwR"
)
```

The function `dbListTables()` in the **DBI** package will tell us what tables exist in the **airlines** database.

```{r}
DBI::dbListTables(con)
flights <- tbl(con, "flights")
carriers <- tbl(con, "carriers")
```

Let's ask a few questions about the data set using data wrangling techniques that should already be familiar.

* Over what years is the `flights` data taken?

To start, let's write the commands using tidy **dplyr** code.

```{r}
yrs <- flights |>
  summarize(min_year = min(year), max_year = max(year))

yrs
```

Because `flights` is not actually a `data.frame` in **R** (but instead a `tbl` in **SQL**), the work that was done above was actually performed in **SQL**.  To see the **SQL** code, we can use the function `show_query`.

```{r}
show_query(yrs)
```

Note the similarity between the **R** code and the **SQL** code.  We can see `SELECT` and `MIN` and `MAX` which are familiar.  The `AS` function is new, but maybe it that `AS` does the job of assigning a new name to the output columns.  `FROM` is also new and does the job of piping in a data set to use.

* Create a data set containing only flights between `LAX` and `BOS` in 2012.

```{r}
la_bos <- flights |>
  filter(year == 2012 & ((origin == "LAX" & dest == "BOS") | 
           (origin == "BOS" & dest == "LAX"))) 


la_bos
```

```{r}
show_query(la_bos)
```

The `WHERE` function in **SQL** acts as `filter()` did in **R**; `&` has been translated to `AND`, and `|` has been translated to `OR`.

Because the data set has been subsetted substantially, we could pull it into **R** to create an **R** object.  Note that now **R** is aware of the size of the entire data frame (7064 rows and 21 columns).  The `la_bos` object now exists in the **R** environment and can be explored through the IDE.  

::: {.callout-tip}

## Watch out

{{< fa triangle-exclamation >}} Be careful with `collect()`! Don't use `collect()` on large dataframes that won't fit in an **R** environment.
:::

```{r}
la_bos <- la_bos |>
  collect()

la_bos
```

@sec-sql-verbs will explore more **SQL** queries and using **SQL** verbs. For now, let's continue learning about the different ways **R** can talk to **SQL**.


## SQL queries through the **DBI** package

Using **R** as a wrapper, we can send actual **SQL** code to query data from the connection.  It is okay if you aren't yet able to write **SQL** commands from scratch, but try to figure out what the command is asking for.  As mentioned above, we will start from scratch to learn **SQL** commands in @sec-sql-verbs.

Start by setting up the **SQL** connection in the same way.

```{r}
con <- DBI::dbConnect(
  RMariaDB::MariaDB(),
  dbname = "airlines",
  host = "mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com",
  user = "mdsr_public",
  password = "ImhsmflMDSwR"
)
```


* Look at the first few rows of the `flights` data.

Because the `flights` data is not an **R** object, we can't open it in **R** to explore the variables.  If we want to see a small bit of the data, we can `SELECT` **everything** (i.e, `*`) from the `flights` table but `LIMIT` the query to only the first eight observations.  

Note that the code in the `dbGetQuery()` **R** function is written in **SQL** not in **R**.

```{r}
DBI::dbGetQuery(con,
                "SELECT * FROM flights LIMIT 8")
```
* How many flights per year are in the `flights` table?

```{r}
dbGetQuery(con, 
  "SELECT year, count(*) AS num_flights FROM flights GROUP BY year ORDER BY num_flights")
```

Note that we've now `SELECT`ed two variables: `year` and `num_flights` (which we created along the way using `count(*)` which is written as `n()` in **R**) `FROM` the `flights` table.  Then we `GROUP BY` the `year` variable which retroactively acts on the `count(*)` function.  And last, we `ORDER BY` (which is similar to `arrange()`) the new `num_flights` variable.


## Direct **SQL** queries through a `sql` chunk

Notice that the formatting of the next few chunks is slightly different. Instead of reporting only the inside / code of the chunk, the entire chunk is printed.  The **SQL** chunks are given by `{sql}` instead of `{r}` and each **SQL** chunk is required to connect to a particular database (through the `con` connection).

The same queries have been run.

Start by setting up the **SQL** connection in the same way.

```{r}
#| echo: fenced

con <- DBI::dbConnect(
  RMariaDB::MariaDB(),
  dbname = "airlines",
  host = "mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com",
  user = "mdsr_public",
  password = "ImhsmflMDSwR"
)
```



```{sql}
#| connection: con
#| echo: fenced

SELECT * FROM flights LIMIT 8
```


```{sql}
#| connection: con
#| echo: fenced

SELECT year, count(*) AS num_flights FROM flights GROUP BY year ORDER BY num_flights
```
