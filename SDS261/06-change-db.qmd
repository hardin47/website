# Changing databases {#sec-change-db}


```{r}
#| include: false

source("_common.R")
```


from mdsr changing data (update) and adding data (insert, insert ignore, replace)


ETL - extract transform load

In order to create a database (on our own computer), we'll start by creating a connection to **DuckDB**. Note that the database has been stored to a database directory called `duck_datab` which lives in the current **R** project.  You won't be able to open it like a standard folder, but it is where **DuckDB** stores the database files.

```{r}
con_duckdb <- DBI::dbConnect(duckdb::duckdb(),
                             dbdir = "duck_datab")
```


## Temporary tables

Temporary tables are used to break down complex queries into smaller, more manageable steps. For example, let's say we want to `JOIN` two tables after each has been filtered using different `WHERE` clauses.  The filtered tables can each be saved into their own temporary tables and then the temporary tables can be merged.  


Note that tables in **DuckDB** are saved (to disk), even when the connection is closed.  However, temporary tables are saved in memory (instead of on disk) and are deleted when the connection is closed.   Specific configuration of the temporary directory allows for <a href = "https://duckdb.org/docs/sql/statements/create_table.html#temporary-tables" target = "_blank">temporary tables to be saved</a>, even when the connection is closed.


###  Using **DuckDB** for loading data {#sec-load-duckdb}

The steps given in @sec-load-data are general to many **SQL** dialects and are important when working with most **SQL** clients.  It is important to have control over the variables configurations as they make up the **SQL** database.  However, using the **duckdb** package in **R** allows for shorthand entry of data from .csv files into the **DuckDB** database.  Here, we take advantage of working with the **DuckDB** functionality in R.



```{r}
duckdb_read_csv(con = con_duckdb, name = "actors", files = "data/actors.csv")
duckdb_read_csv(con = con_duckdb, name = "seasons", files = "data/seasons.csv")
duckdb_read_csv(con = con_duckdb, name = "titles", files = "data/titles.csv")
duckdb_read_csv(con = con_duckdb, name = "hosts", files = "data/hosts.csv")
duckdb_read_csv(con = con_duckdb, name = "episodes", files = "data/episodes.csv")
```

#### Checking the loading {-}

```{sql}
#| connection: con_duckdb

SHOW TABLES;
```


Notice that most of the tables have some kind of ID which allows `JOIN`ing across tables.

```{sql}
#| connection: con_duckdb
#| label: select-actors
#| output.var: "select_actors"

SELECT * FROM actors LIMIT 10;
```

```{r}
#| label: tbl-select-actors
#| echo: false
#| tbl-cap: "Note the aid identifier in the actors table."

select_actors |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```



```{sql}
#| connection: con_duckdb
#| label: select-episodes
#| output.var: "select_episodes"

SELECT * FROM episodes LIMIT 10;
```

```{r}
#| label: tbl-select-episodes
#| echo: false
#| tbl-cap: "Note the sid and epid identifiers in the episodes table."

select_episodes |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```



```{sql}
#| connection: con_duckdb
#| label: select-titles
#| output.var: "select_titles"

SELECT * FROM titles LIMIT 10;
```

```{r}
#| label: tbl-select-titles
#| echo: false
#| tbl-cap: "Note the epid, tid, skid, and sid identifiers in the titles table."

select_titles |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```


```{sql}
#| connection: con_duckdb
#| label: select-hosts
#| output.var: "select_hosts"

SELECT * FROM hosts LIMIT 10;
```


```{r}
#| label: tbl-select-hosts
#| echo: false
#| tbl-cap: "Note the epid and aid identifiers in the hosts table."

select_hosts |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```

### Creating a temporary table

The `episodes` table has an `aired` column which includes the data.  Recall that if we create a new variable (e.g., `year`) using `aired`, we cannot use `year` in the `WHERE` clause (`WHERE` only works on the original table, not the results set). 

In **MySQL** the function `STR_TO_DATE` allowed us to create a datetime variable from which year could be extracted.  However, in **DuckDB**, it is more complicated to convert the character string of "April 10, 2020" to "2020-04-10".  Don't worry about the code too much, but note that we wouldn't want to wrangle the character date string every time we wanted to filter for year.

#### What does `POSITION` do?  {-}

In case you are curious about the date wrangling code... consider `SUBSTRING(aired, POSITION(',' IN aired) + 2)`

1. `POSITION(',' IN aired)`: This part of the expression uses the `POSITION` function to find the position of the first occurrence of the comma (`,`) in the string `aired`. The result is the index (position) of the comma within the string.

2. `POSITION(',' IN aired) + 2`: This adds 2 to the index of the comma. The `+ 2` is used to move the starting point of the substring two positions to the right of the comma. This is done to exclude the comma itself and any following spaces.

3. `SUBSTRING(aired, POSITION(',' IN aired) + 2)`: This part uses the SUBSTRING function to extract a substring from the string `aired`. The starting position of the substring is determined by `POSITION(',' IN aired) + 2`, and it goes until the end of the string. This effectively removes the part of the string that comes before and including the first comma.

In summary, the entire expression is extracting a substring from the original string `aired`, starting from two positions to the right of the first comma and continuing until the end of the string. This can be useful in scenarios where you want to remove or isolate part of a string based on the position of a specific character (in this case, the comma).



```{sql}
#| connection: con_duckdb
#| echo: false
#| include: false

DROP TABLE IF EXISTS episodes_date;
```


```{sql}
#| connection: con_duckdb
    
CREATE TEMP TABLE episodes_date AS
    SELECT *, CASE
             WHEN POSITION(',' IN aired) > 0 THEN
    EXTRACT(YEAR FROM CAST(
                SUBSTRING(aired, POSITION(',' IN aired) + 2) || '-' ||
                CASE
                    WHEN POSITION('January' IN aired) > 0 THEN '01'
                    WHEN POSITION('February' IN aired) > 0 THEN '02'
                    WHEN POSITION('March' IN aired) > 0 THEN '03'
                    WHEN POSITION('April' IN aired) > 0 THEN '04'
                    WHEN POSITION('May' IN aired) > 0 THEN '05'
                    WHEN POSITION('June' IN aired) > 0 THEN '06'
                    WHEN POSITION('July' IN aired) > 0 THEN '07'
                    WHEN POSITION('August' IN aired) > 0 THEN '08'
                    WHEN POSITION('September' IN aired) > 0 THEN '09'
                    WHEN POSITION('October' IN aired) > 0 THEN '10'
                    WHEN POSITION('November' IN aired) > 0 THEN '11'
                    WHEN POSITION('December' IN aired) > 0 THEN '12'
                    ELSE '01' -- Default to January if no month is found
                END || '-' ||
                SUBSTRING(aired, POSITION(' ' IN aired) + 1, 2) AS DATE
            ))
            END AS year FROM episodes;
```


```{sql}
#| connection: con_duckdb
#| label: episodes-date
#| output.var: "episodes_date"

SELECT * FROM episodes_date LIMIT 10;
```

```{r}
#| label: tbl-episodes-date
#| echo: false
#| tbl-cap: "The temporary table called `episodes_date` that has identifiers of sid, epid, and epno."

episodes_date |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```

### Using a temporary table

Now that the `year` variable has been created in the new temporary table called `episodes_date`, we can use `episode_date` to query and find, for example, all of the hosts in 2019.

```{sql}
#| connection: con_duckdb
#| label: hosts-2019
#| output.var: "hosts_2019"

SELECT hosts.aid, ep.aired, ep.year FROM hosts 
JOIN episodes_date AS ep ON hosts.epid = ep.epid
WHERE year = 2019
LIMIT 25;
```

```{r}
#| label: tbl-hosts-2019
#| echo: false
#| tbl-cap: "SNL hosts in 2019."

hosts_2019 |>
  kbl(linesep = "", booktabs = TRUE) |>
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                latex_options = c("striped", "hold_position"),
                full_width = FALSE) 

```



## Best practice

It is always a good idea to terminate the **SQL** connection when you are done with it.

```{r}
dbDisconnect(con_duckdb, shutdown = TRUE)
```





