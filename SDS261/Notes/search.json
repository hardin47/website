[
  {
    "objectID": "01-db.html#quarto",
    "href": "01-db.html#quarto",
    "title": "\n1  What is a Database?\n",
    "section": "\n1.1 Quarto",
    "text": "1.1 Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "01-db.html#running-code",
    "href": "01-db.html#running-code",
    "title": "\n1  What is a Database?\n",
    "section": "\n1.2 Running Code",
    "text": "1.2 Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "02-sql-in-R.html",
    "href": "02-sql-in-R.html",
    "title": "\n2  SQL in R\n",
    "section": "",
    "text": "Note that there exists an R interface to work with SQL commands from within an R Markdown file. For consistency with the class notes, we’ve continued to use the R Markdown structure to demonstrate the course material.\n(Taken from the Teach Data Science blog: https://teachdatascience.com/sql/, this entry written by Nick Horton)\nSQL (pronounced sequel) stands for Structured Query Language; it is a language designed to manage data in a relational database system.\nWe will use a public facing MySQL database containing wideband acoustic immittance (WAI) measures made on normal ears of adults. (The project is funded by the National Institutes of Health, NIDCD, and hosted on a server at Smith College, PI Susan Voss, R15 DC014129-01.) The database was created to enable auditory researchers to share WAI measurements and combine analyses over multiple datasets.\nWe begin by demonstrating how SQL queries can be sent to a database. It is necessary to set up a connection using the dbConnect() function.\n\nlibrary(mosaic)\nlibrary(RMySQL)  \ncon &lt;- dbConnect(\n  RMySQL::MySQL(), host = \"scidb.smith.edu\", user = \"waiuser\", \n  password = \"smith_waiDB\", dbname = \"wai\")\n\nNext a series of SQL queries can be sent to the database using the DBI::dbGetQuery() function: each query returns an R dataframe.\n\nclass(dbGetQuery(con, \"SHOW TABLES\"))\n\nThere are multiple tables within the wai database.\n\ndbGetQuery(con, \"SHOW TABLES\")\n\nThe EXPLAIN command describes the ten field names (variables) in the PI_Info table.\n\ndbGetQuery(con, \"EXPLAIN PI_Info\")\n\nThe SELECT statement can be used to select all fields for eight observations in the Measurements table.\n\neightobs &lt;- dbGetQuery(con, \"SELECT * FROM Measurements LIMIT 8\")\neightobs\n\nMore interesting and complicated SELECT calls can be used to undertake grouping and aggregation. Here we calculate the sample size for each study\n\ndbGetQuery(con, \n  \"SELECT Identifier, count(*) AS NUM FROM Measurements GROUP BY Identifier ORDER BY NUM\")\n\nAccessing a database using dplyr commands\nAlternatively, a connection can be made to the server by creating a series of dplyr tbl objects. Connecting with familiar dplyr syntax is attractive because, as Hadley Wickham has noted, SQL and R have similar syntax (but sufficiently different to be confusing).\nThe setup process looks similar.\n\nMeasurements &lt;- tbl(con, \"Measurements\")\nclass(Measurements)\nPI_Info &lt;- tbl(con, \"PI_Info\")\nSubject &lt;- tbl(con, \"Subjects\")\n\nWe explore the PI_Info table using the collect() function used to force computation on the database (and return the results). One attractive aspect of database systems is that they feature lazy evaluation, where computation is optimized and postponed as long as possible.\n\nPI_Info %&gt;% collect() %&gt;% data.frame()   \n# be careful with collect() when dealing with large tables!\n\nNote how the number of rows is unknown (?? at the top of the output above) for the lazy query.\nSimilarly, we can explore the Subjects table.\n\n#Subject  %&gt;% summarise(total = n())\nSubject %&gt;% collect()  # be careful with collect() with large tables!\n\nLet’s explore the Measurements table.\n\n#Measurements %&gt;% summarise(total = n())\nMeasurements %&gt;% collect()\n\nThere are more than a quarter million observations.\nIn the next step, we will download the data from a given subject for a specific study, in this case a paper by Rosowski et al. (2012) entitled “Ear-canal reflectance, umbo velocity, and tympanometry in normal-hearing adults”.\nArbitrarily we choose to collect data from subject number three.\n\nonesubj &lt;- \n  Measurements %&gt;% \n  filter(Identifier == \"Rosowski_2012\", Sub_Number == 3) %&gt;%\n  collect %&gt;%\n  mutate(SessionNum = as.factor(Session))\nhead(onesubj)\n\nFinally we can display the results of the measurements as a function of frequency and which ear (left or right) that was used.\n\nonesubj &lt;- mutate(onesubj, Ear = ifelse(Left_Ear == 1, \"Left\", \"Right\"))\nggplot(onesubj, aes(x = Freq, y = Absorbance)) + geom_point() +\n  aes(colour = Ear) + scale_x_log10() + labs(title=\"Absorbance by ear Rosowski subject 3\")\n\nAlways a good idea to terminate the SQL connection.\n\ndbDisconnect(con)\n\nWe note that a number of relational database systems exist, including MySQL (illustrated here), PostgreSQL, and SQLite. More information about databases within R can be found in the CRAN Databases with R Task View.\nSetting up and managing a database is a topic for a different day: here we focused on how SQL can be used within R to access data in a flexible and powerful manner.\nLearn more\n\nhttps://chance.amstat.org/2015/04/setting-the-stage/ (Setting the stage for data technologies)\nhttps://www.w3schools.com/sql/sql_intro.asp (Intro to SQL)\nhttp://www.science.smith.edu/wai-database/home/about/ (WAI SQL Database)\nhttps://cran.r-project.org/web/views/Databases.html (CRAN Task View on Databases with R)\nhttps://db.rstudio.com (RStudio Database resources)\nhttps://dbplyr.tidyverse.org/articles/dbplyr.html (dbplyr package)"
  },
  {
    "objectID": "04-sql-verbs.html#quarto",
    "href": "04-sql-verbs.html#quarto",
    "title": "\n3  SQL verbs\n",
    "section": "\n3.1 Quarto",
    "text": "3.1 Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "04-sql-verbs.html#running-code",
    "href": "04-sql-verbs.html#running-code",
    "title": "\n3  SQL verbs\n",
    "section": "\n3.2 Running Code",
    "text": "3.2 Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "07-reg-expr.html",
    "href": "07-reg-expr.html",
    "title": "4  Regular Expressions",
    "section": "",
    "text": "A regular expression … is a sequence of characters that define a search pattern. Usually such patterns are used by string searching algorithms for “find” or “find and replace” operations on strings, or for input validation. It is a technique developed in theoretical computer science and formal language theory. [From https://en.wikipedia.org/wiki/Regular_expression]\n\nMain tasks in character matching:\n\nbasic string operations\npattern matching (regular expressions)\nsentiment analysis\n\nThe ideas below are mostly taken from Jenny Bryan’s STAT545 class: https://github.com/STAT545-UBC/STAT545-UBC-original-website/blob/master/block022_regular-expression.rmd\nR packages to make your life easier\n\n\nstringr package A core package in the tidyverse. It is installed via install.packages(\"tidyverse\") and also loaded via library(tidyverse). Of course, you can also install or load it individually.\n\nMany of the main functions start with str_. Auto-complete is your friend.\nReplacements for base functions re: string manipulation and regular expressions (see below).\nMain advantages over base functions: greater consistency about inputs and outputs. Outputs are more ready for your next analytical task.\n\nstringr cheat sheet: https://github.com/rstudio/cheatsheets/raw/master/strings.pdf\n\n\n\ntidyr package Especially useful for functions that split one character vector into many and vice versa: separate(), unite(), extract().\nBase functions: nchar(), strsplit(), substr(), paste(), paste0().\nThe glue package is fantastic for string interpolation. If stringr::str_interp() doesn’t get your job done, check out the glue package.\nString functions related to regular expression\nRegular expression is a pattern that describes a specific set of strings with a common structure. It is heavily used for string matching / replacing in all programming languages, although specific syntax may differ a bit. It is truly the heart and soul for string operations. In R, many string functions in base R as well as in stringr package use regular expressions, even Rstudio’s search and replace allows regular expression:\n\nidentify match to a pattern: grep(..., value = FALSE), grepl(), stringr::str_detect()\n\nextract match to a pattern: grep(..., value = TRUE), stringr::str_extract(), stringr::str_extract_all()\n\nlocate pattern within a string, i.e. give the start position of matched patterns. regexpr(), gregexpr(), stringr::str_locate(), string::str_locate_all()\n\nreplace a pattern: sub(), gsub(), stringr::str_replace(), stringr::str_replace_all()\n\nsplit a string using a pattern: strsplit(), stringr::str_split()\n\n\nRegular expressions typically specify characters (or character classes) to seek out, possibly with information about repeats and location within the string. This is accomplished with the help of metacharacters that have specific meaning: $ * + . ? [ ] ^ { } | ( ) \\. We will use some small examples to introduce regular expression syntax and what these metacharacters mean.\nEscape sequences\nThere are some special characters in R that cannot be directly coded in a string. For example, let’s say you specify your pattern with single quotes and you want to find countries with the single quote '. You would have to “escape” the single quote in the pattern, by preceding it with \\, so it is clear that it is not part of the string-specifying machinery.\nThere are other characters in R that require escaping, and this rule applies to all string functions in R, including regular expressions. See here for a complete list of R escape sequences.\n\n\n\\': single quote. You don’t need to escape single quote inside a double-quoted string, so we can also use \"'\" in the previous example.\n\n\n\\\": double quote. Similarly, double quotes can be used inside a single-quoted string, i.e. '\"'.\n\n\n\\n: newline.\n\n\n\\r: carriage return.\n\n\n\\t: tab character.\n\n\nNote: cat() and print() handle escape sequences differently, if you want to print a string out with these sequences interpreted, use cat().\n\n\nprint(\"a\\nb\")\n\n[1] \"a\\nb\"\n\ncat(\"a\\nb\")\n\na\nb\n\n\nQuantifiers\nQuantifiers specify how many repetitions of the pattern.\n\n\n*: matches at least 0 times.\n\n\n+: matches at least 1 times.\n\n\n?: matches at most 1 times.\n\n\n{n}: matches exactly n times.\n\n\n{n,}: matches at least n times.\n\n\n{n,m}: matches between n and m times.\n\n\n(strings &lt;- c(\"a\", \"ab\", \"acb\", \"accb\", \"acccb\", \"accccb\"))\n\n[1] \"a\"      \"ab\"     \"acb\"    \"accb\"   \"acccb\"  \"accccb\"\n\ngrep(\"ac*b\", strings, value = TRUE)\n\n[1] \"ab\"     \"acb\"    \"accb\"   \"acccb\"  \"accccb\"\n\ngrep(\"ac*b\", strings, value = FALSE)\n\n[1] 2 3 4 5 6\n\ngrep(\"ac+b\", strings, value = TRUE)\n\n[1] \"acb\"    \"accb\"   \"acccb\"  \"accccb\"\n\ngrep(\"ac?b\", strings, value = TRUE)\n\n[1] \"ab\"  \"acb\"\n\ngrep(\"ac{2}b\", strings, value = TRUE)\n\n[1] \"accb\"\n\ngrep(\"ac{2}b\", strings, value = FALSE)\n\n[1] 4\n\ngrep(\"ac{2,}b\", strings, value = TRUE)\n\n[1] \"accb\"   \"acccb\"  \"accccb\"\n\ngrep(\"ac{2,3}b\", strings, value = TRUE)\n\n[1] \"accb\"  \"acccb\"\n\n\nPosition of pattern within the string\n\n\n^: matches the start of the string.\n\n\n$: matches the end of the string.\n\n\n\\b: matches the empty string at either edge of a word. Don’t confuse it with ^ $ which marks the edge of a string.\n\n\n\\B: matches the empty string provided it is not at an edge of a word.\n\n\n(strings &lt;- c(\"abcd\", \"cdab\", \"cabd\", \"c abd\"))\n\n[1] \"abcd\"  \"cdab\"  \"cabd\"  \"c abd\"\n\ngrep(\"ab\", strings, value = TRUE)\n\n[1] \"abcd\"  \"cdab\"  \"cabd\"  \"c abd\"\n\ngrep(\"^ab\", strings, value = TRUE)\n\n[1] \"abcd\"\n\ngrep(\"ab$\", strings, value = TRUE)\n\n[1] \"cdab\"\n\ngrep(\"\\\\bab\", strings, value = TRUE)\n\n[1] \"abcd\"  \"c abd\"\n\n\nOperators\n\n\n.: matches any single character, as shown in the first example.\n\n[...]: a character list, matches any one of the characters inside the square brackets. We can also use - inside the brackets to specify a range of characters.\n\n\n[^...]: an inverted character list, similar to [...], but matches any characters except those inside the square brackets.\n\n\n\\: suppress the special meaning of metacharacters in regular expression, i.e. $ * + . ? [ ] ^ { } | ( ) \\, similar to its usage in escape sequences. Since \\ itself needs to be escaped in R, we need to escape these metacharacters with double backslash like \\\\$.\n\n\n|: an “or” operator, matches patterns on either side of the |.\n\n\n(...): grouping in regular expressions. This allows you to retrieve the bits that matched various parts of your regular expression so you can alter them or use them for building up a new string. Each group can than be refer using \\\\N, with N being the No. of (...) used. This is called backreference.\n\n\n(strings &lt;- c(\"^ab\", \"ab\", \"abc\", \"abd\", \"abe\", \"ab 12\"))\n\n[1] \"^ab\"   \"ab\"    \"abc\"   \"abd\"   \"abe\"   \"ab 12\"\n\ngrep(\"ab.\", strings, value = TRUE)\n\n[1] \"abc\"   \"abd\"   \"abe\"   \"ab 12\"\n\ngrep(\"ab[c-e]\", strings, value = TRUE)\n\n[1] \"abc\" \"abd\" \"abe\"\n\ngrep(\"ab[^c]\", strings, value = TRUE)\n\n[1] \"abd\"   \"abe\"   \"ab 12\"\n\ngrep(\"^ab\", strings, value = TRUE)\n\n[1] \"ab\"    \"abc\"   \"abd\"   \"abe\"   \"ab 12\"\n\ngrep(\"\\\\^ab\", strings, value = TRUE)\n\n[1] \"^ab\"\n\ngrep(\"abc|abd\", strings, value = TRUE)\n\n[1] \"abc\" \"abd\"\n\ngsub(\"(ab) 12\", \"\\\\1 34\", strings)\n\n[1] \"^ab\"   \"ab\"    \"abc\"   \"abd\"   \"abe\"   \"ab 34\"\n\n\nCharacter classes\nCharacter classes allow specifying entire classes of characters, such as numbers, letters, etc. There are two flavors of character classes, one uses [: and :] around a predefined name inside square brackets and the other uses \\ and a special character. They are sometimes interchangeable.\n\n\n[:digit:] or \\d: digits, 0 1 2 3 4 5 6 7 8 9, equivalent to [0-9].\n\n\n\\D: non-digits, equivalent to [^0-9].\n\n\n[:lower:]: lower-case letters, equivalent to [a-z].\n\n\n[:upper:]: upper-case letters, equivalent to [A-Z].\n\n\n[:alpha:]: alphabetic characters, equivalent to [[:lower:][:upper:]] or [A-z].\n\n\n[:alnum:]: alphanumeric characters, equivalent to [[:alpha:][:digit:]] or [A-z0-9].\n\n\n\\w: word characters, equivalent to [[:alnum:]_] or [A-z0-9_].\n\n\n\\W: not word, equivalent to [^A-z0-9_].\n\n\n[:xdigit:]: hexadecimal digits (base 16), 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f, equivalent to [0-9A-Fa-f].\n\n[:blank:]: blank characters, i.e. space and tab.\n\n\n[:space:]: space characters: tab, newline, vertical tab, form feed, carriage return, space.\n\n\\s: space, .\n\n\n\\S: not space.\n\n\n[:punct:]: punctuation characters, ! ” # $ % & ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [  ] ^ _ ` { | } ~.\n\n[:graph:]: graphical (human readable) characters: equivalent to [[:alnum:][:punct:]].\n\n[:print:]: printable characters, equivalent to [[:alnum:][:punct:]\\\\s].\n\n[:cntrl:]: control characters, like \\n or \\r, [\\x00-\\x1F\\x7F].\n\nNote:\n* [:...:] has to be used inside square brackets, e.g. [[:digit:]].\n* \\ itself is a special character that needs escape, e.g. \\\\d. Do not confuse these regular expressions with R escape sequences such as \\t.\nstringr\nIn many cases, you will want to use the incredibly useful and tidy set of functions available in the stringr package. (stringr is a core package in the tidyverse.) For example, below we’ve extracted the first (and then last) word as a character string from the StreetName variable.\n\n\nstringr cheat sheet: https://github.com/rstudio/cheatsheets/raw/master/strings.pdf\n\n\nlibrary(Stat2Data)\ndata(RailsTrails)\nRailsTrails &lt;- RailsTrails |&gt; \n  select(HouseNum, Bedrooms, Price2014, StreetName) \nRailsTrails |&gt; head()\n\n  HouseNum Bedrooms Price2014      StreetName\n1        1        3       211 Acrebrook Drive\n2        2        3       204       Autumn Dr\n3        3        3       339     Bridge Road\n4        4        3       276     Bridge Road\n5        5        4       169     Bridge Road\n6        6        3       211 Brierwood Drive\n\nRailsTrails |&gt;\n  mutate(first_piece = stringr::word(StreetName, start = 1)) |&gt; head()\n\n  HouseNum Bedrooms Price2014      StreetName first_piece\n1        1        3       211 Acrebrook Drive   Acrebrook\n2        2        3       204       Autumn Dr      Autumn\n3        3        3       339     Bridge Road      Bridge\n4        4        3       276     Bridge Road      Bridge\n5        5        4       169     Bridge Road      Bridge\n6        6        3       211 Brierwood Drive   Brierwood\n\nRailsTrails |&gt;\n  mutate(last_piece = stringr::word(StreetName, start = -1)) |&gt; head()\n\n  HouseNum Bedrooms Price2014      StreetName last_piece\n1        1        3       211 Acrebrook Drive      Drive\n2        2        3       204       Autumn Dr         Dr\n3        3        3       339     Bridge Road       Road\n4        4        3       276     Bridge Road       Road\n5        5        4       169     Bridge Road       Road\n6        6        3       211 Brierwood Drive      Drive\n\n\nAn example from my work\nBelow are a handful of string characters that represent genomic sequences which were measured in an RNA Sequencing dataset. The task below is to find intergenic regions (IGR) and identify which coding sequences (CDS) bookend the intergenic regions. Note that IGRs do not code for proteins while CDSs do. Additionally, AS refers to anti-sense which identifies the genomic sequence in the opposite orientation (e.g., CGGATCC vs CCTAGGC). [The code below was written by Madison Hobbs, Scripps ’19.]\nThe names of the genomic pieces\n\nallCounts &lt;- data.frame(Geneid = c(\"CDS:b2743:pcm:L-isoaspartate_protein_carboxylmethyltransferase_type_II:cds2705:-:626:NC_000913.3\",\n            \"CDS:b2764:cysJ:sulfite_reductase2C_alpha_subunit2C_flavoprotein:cds2726:-:1799:NC_000913.3\",\n            \"IGR:(CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893):+:945:NC_000913.3\",\n            \"AS_IGR:(CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587):+:639:NC_000913.3\",\n            \"IGR:(CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344):+:396:NC_000913.3\"))\n\nallCounts$GeneidBackup = allCounts$Geneid\n\nFirst, it is important to identify which are IGR, CDS, and anti-sense.\n\nallCounts &lt;- allCounts |&gt; tidyr::separate(Geneid, c(\"feature\", \"rest\"), sep=\"[:]\")\nallCounts\n\n  feature\n1     CDS\n2     CDS\n3     IGR\n4  AS_IGR\n5     IGR\n                                                                                                                                                                                       rest\n1                                                                                                                                                                                     b2743\n2                                                                                                                                                                                     b2764\n3 (CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893)\n4                                                         (CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587)\n5                                       (CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344)\n                                                                                                                                                                                                     GeneidBackup\n1                                                                                                                CDS:b2743:pcm:L-isoaspartate_protein_carboxylmethyltransferase_type_II:cds2705:-:626:NC_000913.3\n2                                                                                                                      CDS:b2764:cysJ:sulfite_reductase2C_alpha_subunit2C_flavoprotein:cds2726:-:1799:NC_000913.3\n3 IGR:(CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893):+:945:NC_000913.3\n4                                                      AS_IGR:(CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587):+:639:NC_000913.3\n5                                       IGR:(CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344):+:396:NC_000913.3\n\n\nWe keep only the IGR and AS_IGR strings, and we separate the two bookends. Note, the separation comes at the backslash.\n\nigr &lt;- allCounts |&gt; filter(feature %in% c(\"IGR\", \"AS_IGR\"))\nigr &lt;- igr |&gt; tidyr::separate(GeneidBackup, c(\"Geneid1\", \"Geneid2\"), sep = \"[/]\")\nnames(igr)\n\n[1] \"feature\" \"rest\"    \"Geneid1\" \"Geneid2\"\n\nigr\n\n  feature\n1     IGR\n2  AS_IGR\n3     IGR\n                                                                                                                                                                                       rest\n1 (CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893)\n2                                                         (CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587)\n3                                       (CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344)\n                                                                                                           Geneid1\n1 IGR:(CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220\n2                                                                AS_IGR:(CDS,b0008,talB,transaldolase_B,cds7,+,953\n3                                 IGR:(CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910\n                                                                                                   Geneid2\n1           CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893):+:945:NC_000913.3\n2 CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587):+:639:NC_000913.3\n3                 CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344):+:396:NC_000913.3\n\n\nFor each of the two bookend Genes, we need to separate out the feature from the rest. Note that we write over feature1 in the second line of code below. Both of the bookends for all sequences are CDS elements.\n\nigr$feature1 &lt;- tidyr::separate(igr, Geneid1, c(\"feature1\", \"rest\"), sep = \"[,]\")$feature1\nigr$feature1 &lt;- tidyr::separate(igr, feature1, c(\"rest\", \"feature1\"), sep = \"[()]\")$feature1\nigr$feature2 &lt;- tidyr::separate(igr, Geneid2, c(\"feature2\", \"rest\"), sep = \"[,]\")$feature2\nnames(igr)\n\n[1] \"feature\"  \"rest\"     \"Geneid1\"  \"Geneid2\"  \"feature1\" \"feature2\"\n\nigr\n\n  feature\n1     IGR\n2  AS_IGR\n3     IGR\n                                                                                                                                                                                       rest\n1 (CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893)\n2                                                         (CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587)\n3                                       (CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344)\n                                                                                                           Geneid1\n1 IGR:(CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220\n2                                                                AS_IGR:(CDS,b0008,talB,transaldolase_B,cds7,+,953\n3                                 IGR:(CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910\n                                                                                                   Geneid2\n1           CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893):+:945:NC_000913.3\n2 CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587):+:639:NC_000913.3\n3                 CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344):+:396:NC_000913.3\n  feature1 feature2\n1      CDS      CDS\n2      CDS      CDS\n3      CDS      CDS\n\n\nAs CDS, it is now important to find the actual genenames for each of the IGR sequences. We also keep each element’s bnum which represents a unique gene identifier in E. coli.\nbnum, genename, rna.name act as place holders for the types of elements that we will need to identify the bookends of the IGRs.\n\nbnum = \"b[0-9]{4}\"\nbnum\n\n[1] \"b[0-9]{4}\"\n\ngenename = \",[a-z]{3}[A-Z,].\"\nrna.name = \",rna[0-9]..\"\n\n\nigr$start.gene &lt;- dplyr::case_when(\n  igr$feature1 == \"CDS\" ~ stringr::str_extract(igr$Geneid1, genename),\n  TRUE ~ stringr::str_extract(igr$Geneid1, rna.name))\nigr$end.gene &lt;- dplyr::case_when(\n  igr$feature2 == \"CDS\" ~ stringr::str_extract(igr$Geneid2, genename),\n  TRUE ~ stringr::str_extract(igr$Geneid2, rna.name))\nigr$start.bnum &lt;- dplyr::case_when(\n  igr$feature1 == \"CDS\" ~ stringr::str_extract(igr$Geneid1, bnum),\n  TRUE ~ \"none\")\nigr$end.bnum &lt;- dplyr::case_when(\n  igr$feature2 == \"CDS\" ~ stringr::str_extract(igr$Geneid2, bnum),\n  TRUE ~ \"none\")\nigr &lt;- igr |&gt; tidyr::separate(start.gene, into = c(\"comma\", \"start.gene\"), sep = \"[,]\") |&gt; \n  dplyr::select(-comma) |&gt; \n  tidyr::separate(end.gene, into = c(\"comma\", \"end.gene\"), sep = \"[,]\") |&gt; \n  dplyr::select(-comma)\nnames(igr)\n\n [1] \"feature\"    \"rest\"       \"Geneid1\"    \"Geneid2\"    \"feature1\"  \n [6] \"feature2\"   \"start.gene\" \"end.gene\"   \"start.bnum\" \"end.bnum\"  \n\nigr\n\n  feature\n1     IGR\n2  AS_IGR\n3     IGR\n                                                                                                                                                                                       rest\n1 (CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220/CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893)\n2                                                         (CDS,b0008,talB,transaldolase_B,cds7,+,953/CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587)\n3                                       (CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910/CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344)\n                                                                                                           Geneid1\n1 IGR:(CDS,b1594,mlc,glucosamine_anaerobic_growth_regulon_transcriptional_repressor3B_autorepressor,cds1581,-,1220\n2                                                                AS_IGR:(CDS,b0008,talB,transaldolase_B,cds7,+,953\n3                                 IGR:(CDS,b1808,yoaA,putative_ATP-dependent_helicase2C_DinG_family,cds1798,-,1910\n                                                                                                   Geneid2\n1           CDS,b1595,ynfL,LysR_family_putative_transcriptional_regulator,cds1582,-,893):+:945:NC_000913.3\n2 CDS,b0009,mog,molybdochelatase_incorporating_molybdenum_into_molybdopterin,cds8,+,587):+:639:NC_000913.3\n3                 CDS,b1809,yoaB,putative_reactive_intermediate_deaminase,cds1799,+,344):+:396:NC_000913.3\n  feature1 feature2 start.gene end.gene start.bnum end.bnum\n1      CDS      CDS        mlc     ynfL      b1594    b1595\n2      CDS      CDS       talB      mog      b0008    b0009\n3      CDS      CDS       yoaA     yoaB      b1808    b1809\n\n\nHelpful tutorials/files\n\n\nstringr vignette: https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html\nstringr package\nJenny Bryan’s STAT 545 notes: https://stat545.com/character-vectors.html\nJenny Bryan’s STAT 545 lab: http://stat545.com/block022_regular-expression.html\nHadley Wickham’s book R for Data Science\n\n\nregexpal\n\n\nRegExr\n\nRegular expression in R official document.\nFun examples\n\nThe name Hilary: https://hilaryparker.com/2013/01/30/hilary-the-most-poisoned-baby-name-in-us-history/\nTrump’s tweets: http://varianceexplained.org/r/trump-tweets/\nTrump’s tweets, take two: http://varianceexplained.org/r/trump-followup/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science, the SQL",
    "section": "",
    "text": "Welcome to Data Science, the SQL\nDaily class notes for Data Science, the SQL, by Jo Hardin, SDS 261 at Smith College. Built on Modern Data Science with R by Baumer, Kaplan, and Horton, 3rd ed. and R for Data Science by Wickham, Çetinkaya-Rundel, and Grolemund, 2nd ed.\nYou are responsible for reading your texts. They are both excellent and readable, so you should use them. That said, you should also make sure you are coming to class and asking lots of questions.\nMore information and course details can be found at the SDS261 website.\n\nCopyright © 2023.\nVersion date: November 29, 2023.\nThe notes are available under a Creative Commons Attribution-ShareAlike 3.0 Unported United States License. License details are available at the Creative Commons website:creativecommons.org.\nSource files for these notes can be found on GitHub athttps://github.com/hardin47/website/tree/gh-pages/SDS261."
  },
  {
    "objectID": "intro-to-sql.html#quarto",
    "href": "intro-to-sql.html#quarto",
    "title": "Untitled",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "intro-to-sql.html#running-code",
    "href": "intro-to-sql.html#running-code",
    "title": "Untitled",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "using-sql.html#quarto",
    "href": "using-sql.html#quarto",
    "title": "Untitled",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "using-sql.html#running-code",
    "href": "using-sql.html#running-code",
    "title": "Untitled",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "reg-expr.html#quarto",
    "href": "reg-expr.html#quarto",
    "title": "Untitled",
    "section": "Quarto",
    "text": "Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "reg-expr.html#running-code",
    "href": "reg-expr.html#running-code",
    "title": "Untitled",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "01-db.html#what-is-a-database",
    "href": "01-db.html#what-is-a-database",
    "title": "1  Databases",
    "section": "\n1.1 What is a database?",
    "text": "1.1 What is a database?\nYou are likely already familiar with the concept of tidy data. (If you have never encountered tidy data, see Chapter 5 Data tidying in R for Data Science.) Tidy data typically live in data frames or tables; where, importantly, they consist of columns of variables (where every column is the same type!) and the rows of observational units.\nConceptually, a table in a database is no different from the data frames which are used in R. They will always be rectangles with the same row and column structure.\nThere are two big differences between a stand alone data frame (e.g., in R) and a table which lives in a database (e.g., in SQL).\n\n\nMost importantly, tables in databases can be arbitrarily large, primarily due to being stored on disk. Indeed, they are typially not stored on your computer’s disk, they are stored remotely on a hard drive outside of your own computer and work space. Data frames are stored in memory (on your computer) and can be quite limited in size.\n\nMemory (RAM) is the amount of data that a computer can work on simultaneously. My computer has 32 GB of RAM. The important thing about memory is that the computer has easy access to its own memory and will access it quickly (tens of GBs per second).\nHard Disk is the amount of data that a computer can store permanently; it is your storage space. My computer has 2 TB of storage. Accessing the disk is much slower (hundreds of MBs per second) than accessing the memory. Accessing disk space is even slower if the storage lives on a different computer and is accessed virtually (via WiFi).\n\n\nThe tables in a database are usually linked with a key. We will cover join() functions in Chapter 4, but keep in mind that in order to get information from one table to connect to information in another table, we need to somehow relate the rows of the first table to the rows of the second table.\n\nTo demonstrate the difference between data frames in memory and tables in storage, we will consider the airlines data consisting of millions of individual flights going back to 1987. The full dataset occupies almost 20GB when they are saved as CSV (comma separated value) files, a common way to hold data that can be represented as columns of text which are separated by commas."
  },
  {
    "objectID": "01-db.html#tables-in-sql",
    "href": "01-db.html#tables-in-sql",
    "title": "1  Databases",
    "section": "\n1.2 Tables in SQL\n",
    "text": "1.2 Tables in SQL\n\nTo look at the airlines data tables, we first need to connect to the database remotely. The function dbConnect_scidb() in the mdsr package allows us to connect to the databases which are stored for use with the text Modern Data Science with R.\nThe tbl() function (in the dplyr package) maps the tables called flights and carriers from the database to an object in R.\n\nlibrary(tidyverse)\nlibrary(mdsr)\ndb_air &lt;- dbConnect_scidb(\"airlines\")\nflights &lt;- tbl(db_air, \"flights\")\ncarriers &lt;- tbl(db_air, \"carriers\")\n\nWe can now use the objects flights and carriers as if they were data frames, but they are not actually the R version of data.frame. Instead, they exist as a tbl which is a special object that behaves similarly to a data.frame.\nThe carriers data represents the name of each airline and the associated carrier code. Note that when the data are printed to screen, the number of rows is given by ??, indicating that they are unknown. Indeed, R just needed the first few rows to print to screen, no need to spend precious computing resources looking at the entire table.\n\ncarriers \n\n# Source:   table&lt;carriers&gt; [?? x 2]\n# Database: mysql  [mdsr_public@mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com:NA/airlines]\n  carrier name                         \n  &lt;chr&gt;   &lt;chr&gt;                        \n1 02Q     Titan Airways                \n2 04Q     Tradewind Aviation           \n3 05Q     Comlux Aviation, AG          \n4 06Q     Master Top Linhas Aereas Ltd.\n5 07Q     Flair Airlines Ltd.          \n6 09Q     Swift Air, LLC               \n# ℹ more rows\n\n\nWith the carriers data, it is possible, however, to load the entire object into R using collect(). Now, when the data are printed to screen, the object is a tibble and R knows that it has 1,610 rows.\n\ncarriers |&gt;\n  collect() \n\n# A tibble: 1,610 × 2\n  carrier name                         \n  &lt;chr&gt;   &lt;chr&gt;                        \n1 02Q     Titan Airways                \n2 04Q     Tradewind Aviation           \n3 05Q     Comlux Aviation, AG          \n4 06Q     Master Top Linhas Aereas Ltd.\n5 07Q     Flair Airlines Ltd.          \n6 09Q     Swift Air, LLC               \n# ℹ 1,604 more rows\n\n\nAs already mentioned, working in R versus working remotely has trade-offs. Remember that the object takes up much more space in your memory if you load it into R. Consider the following which demonstrates how much more memory intensive it is to hold an object in R.\n\n# carriers lives in the SQL database and is linked remotely\ncarriers |&gt;\n  object.size() |&gt;\n  print(units = \"Kb\")\n\n5.2 Kb\n\n\n\n# carriers lives in R\ncarriers |&gt;\n  collect() |&gt;\n  object.size() |&gt;\n  print(units = \"Kb\")\n\n234.8 Kb\n\n\nIndeed, the flights data set contains all of the flights and is much larger than the carriers data set. When pulled into R it takes up almost 5 GB of memory (!), but when it exists as only a connection to the SQL database is uses just a few Kb of memory.\n\n# flights lives in the database and is linked remotely\nflights |&gt;\n  object.size() |&gt;\n  print(units = \"Kb\")\n\n6.5 Kb\n\n\nAlways a good idea to terminate the SQL connection when you are done with it.\n\nlibrary(DBI)\ndbDisconnect(db_air)"
  },
  {
    "objectID": "01-db.html#many-sql-interfaces",
    "href": "01-db.html#many-sql-interfaces",
    "title": "1  Databases",
    "section": "\n1.3 Many SQL interfaces",
    "text": "1.3 Many SQL interfaces\nSQL (Structured Query Language) is a programming language for working with relational databases. (The relational part means that the datasets are connected in a meaningful way, the database part means that we have lots of tables living somewhere remotely on a hard drive.) SQL has been around since the 1970s and is extremely powerful for data wrangling tasks.\nAlthough SQL has been a standard for the American National Standards Institute (ANSI) since 1986, there exist many dialects of SQL. Translating between the dialects is not always easy although once you learn how to program in one dialect, you will be able to pick up any of the other SQL dialects. We will use MySQL in this class. MySQL is among the most popular implementations of SQL and it is open source."
  },
  {
    "objectID": "01-db.html#engaging-with-a-database",
    "href": "01-db.html#engaging-with-a-database",
    "title": "1  Databases",
    "section": "\n1.3 Engaging with a database",
    "text": "1.3 Engaging with a database\n\n1.3.1 Many SQL implementations\nSQL (Structured Query Language) is a programming language for working with relational databases. (The relational part means that the data sets are connected in a meaningful way, the database part means that we have lots of tables living somewhere remotely on a hard drive.) SQL has been around since the 1970s and is extremely powerful for data wrangling tasks.\nAlthough SQL has been a standard for the American National Standards Institute (ANSI) since 1986, there exist many dialects of SQL. Translating between the dialects is not always easy although once you learn how to program in one dialect, you will be able to pick up any of the other SQL dialects. We will use MySQL in this class. MySQL is among the most popular implementations of SQL and it is open source.\n\n1.3.2 SQL interfaces\nMySQL is based on a client-server model. The data live on a powerful computer (the server) and you connect to the data from your own computer (the client). In this class:\n\n\nSQL code will be written in the MySQL dialect\nusing both RStudio and DBeaver as the interface to\nconnect to many different remote servers.\n\n1.3.3 SQL in-process\nAnother approach to engaging with SQL is where the client and the server are both on a single computer (called in-process). You may want to set up a database on your own computer to try things out and avoid monthly charges associated with buying server space in the cloud. Indeed, for the end of the semester project, if you choose to set up a database on your own computer, a good free database management system is Duckdb"
  },
  {
    "objectID": "01-db.html#section",
    "href": "01-db.html#section",
    "title": "1  Databases",
    "section": "\n1.4 ",
    "text": "1.4"
  },
  {
    "objectID": "01-db.html#sec-what-db",
    "href": "01-db.html#sec-what-db",
    "title": "1  Databases",
    "section": "\n1.1 What is a database?",
    "text": "1.1 What is a database?\nYou are likely already familiar with the concept of tidy data. (If you have never encountered tidy data, see Chapter 5 Data tidying in R for Data Science.) Tidy data typically live in data frames or tables; where, importantly, they consist of columns of variables (where every column is the same type!) and the rows of observational units.\nConceptually, a table in a database is no different from the data frames which are used in R. They will always be rectangles with the same row and column structure.\nThere are two big differences between a stand alone data frame (e.g., in R) and a table which lives in a database (e.g., in SQL).\n\n\nMost importantly, tables in databases can be arbitrarily large, primarily due to being stored on disk. Indeed, they are typially not stored on your computer’s disk, they are stored remotely on a hard drive outside of your own computer and work space. Data frames are stored in memory (on your computer) and can be quite limited in size.\n\nMemory (RAM) is the amount of data that a computer can work on simultaneously. My computer has 32 GB of RAM. The important thing about memory is that the computer has easy access to its own memory and will access it quickly (tens of GBs per second).\nHard Disk is the amount of data that a computer can store permanently; it is your storage space. My computer has 2 TB of storage. Accessing the disk is much slower (hundreds of MBs per second) than accessing the memory. Accessing disk space is even slower if the storage lives on a different computer and is accessed virtually (via WiFi).\n\n\nThe tables in a database are usually linked with a key. We will cover join() functions in Chapter 4, but keep in mind that in order to get information from one table to connect to information in another table, we need to somehow relate the rows of the first table to the rows of the second table.\n\nTo demonstrate the difference between data frames in memory and tables in storage, we will consider the airlines data consisting of millions of individual flights going back to 1987. The full data set occupies almost 20GB when they are saved as CSV (comma separated value) files, a common way to hold data that can be represented as columns of text which are separated by commas."
  },
  {
    "objectID": "01-db.html#connecting-to-a-database",
    "href": "01-db.html#connecting-to-a-database",
    "title": "1  Databases",
    "section": "\n1.4 Connecting to a database",
    "text": "1.4 Connecting to a database\nWhen using R to connect to a database, we need two R packages. DBI is a low-level interface that connects to databases and executes SQL; RMariaDB is a package specifically tailored for MySQL which translates generic DBI commands into the specific syntax needed for MySQL.\nA third R pacakge, dbplyr, is a high-level interface that translates dplyr code (i.e., R code) to SQL queries then executes them with DBI.\n\n1.4.1 Creating a database connection\nBefore we can do anything, we need to set up a connection to a MySQL database. We will call the connection con, and the syntax will look something like what is written below. However, the code below won’t run because values must be set for dbname, host, user, and password.\n\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  dbname = \"  \",\n  host = \"  \",\n  user = \"  \",\n  password = \"  \"\n)\n\nNote that the function dbConnect_scidb() in the mdsr package is just a wrapper of the dbConnect() function where all the arguments are filled in to connect to the mdsr database.\nAlways a good idea to terminate the SQL connection when you are done with it.\n\ndbDisconnect(con)\n\n\n1.4.2 Connecting to Duckdb\nConnecting to Duckdb is reasonably straightforward because the default values of the duckdb() function in the duckdb package create a temporary database that is deleted when you quit R.\n\ncon_duckdb &lt;- DBI::dbConnect(duckdb::duckdb())\n\nAlways a good idea to terminate the SQL connection when you are done with it.\n\ndbDisconnect(con_duckdb)"
  },
  {
    "objectID": "01-db.html#sec-dplyr-seq",
    "href": "01-db.html#sec-dplyr-seq",
    "title": "1  Databases",
    "section": "\n1.5 Translating dplyr code into SQL",
    "text": "1.5 Translating dplyr code into SQL\nLet’s go back to the airlines database to try out some things that we already know how to do in R. Recall that we need the DBI and RMariaDB packages to connect to R; we need the dbplyr package to translate SQL code into R.\n\nlibrary(DBI)\nlibrary(RMariaDB)\nlibrary(dbplyr)\n\ncon &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  dbname = \"airlines\",\n  host = \"mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com\",\n  user = \"mdsr_public\",\n  password = \"ImhsmflMDSwR\"\n)\n\nThe function dbListTables() in the DBI package will tell us what tables exist in the airlines database.\n\nDBI::dbListTables(con)\n\n[1] \"airports\" \"carriers\" \"flights\"  \"planes\""
  },
  {
    "objectID": "05-creating-db.html",
    "href": "05-creating-db.html",
    "title": "5  Creating databases",
    "section": "",
    "text": "see 21.3.2 in R4DS https://r4ds.hadley.nz/databases#sec-load-data"
  },
  {
    "objectID": "02-sql-in-R.html#sec-dplyr-seq",
    "href": "02-sql-in-R.html#sec-dplyr-seq",
    "title": "2  SQL in R",
    "section": "\n2.1 Translating dplyr code into SQL",
    "text": "2.1 Translating dplyr code into SQL\nLet’s go back to the airlines database to try out some things that we already know how to do in R. Recall that we need the DBI and RMariaDB packages to connect to R; we need the dbplyr package to translate SQL code into R.\n\nlibrary(DBI)\nlibrary(RMariaDB)\nlibrary(dbplyr)\n\ncon_air &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  dbname = \"airlines\",\n  host = \"mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com\",\n  user = \"mdsr_public\",\n  password = \"ImhsmflMDSwR\"\n)\n\nThe function dbListTables() in the DBI package will tell us what tables exist in the airlines database.\n\nDBI::dbListTables(con_air)\n\n[1] \"airports\" \"carriers\" \"flights\"  \"planes\"  \n\nflights &lt;- tbl(con_air, \"flights\")\ncarriers &lt;- tbl(con_air, \"carriers\")\n\nLet’s ask a few questions about the data set using data wrangling techniques that should already be familiar.\n\nOver what years is the flights data taken?\n\nTo start, let’s write the commands using tidy dplyr code.\n\nyrs &lt;- flights |&gt;\n  summarize(min_year = min(year), max_year = max(year))\n\nyrs\n\n# Source:   SQL [1 x 2]\n# Database: mysql  [mdsr_public@mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com:NA/airlines]\n  min_year max_year\n     &lt;int&gt;    &lt;int&gt;\n1     2010     2017\n\n\nBecause flights is not actually a data.frame in R (but instead a tbl in SQL), the work that was done above was actually performed in SQL. To see the SQL code, we can use the function show_query.\n\nshow_query(yrs)\n\n&lt;SQL&gt;\nSELECT MIN(`year`) AS `min_year`, MAX(`year`) AS `max_year`\nFROM `flights`\n\n\nNote the similarity between the R code and the SQL code. We can see SELECT and MIN and MAX which are familiar. The AS function is new, but maybe it that AS does the job of assigning a new name to the output columns. FROM is also new and does the job of piping in a data set to use.\n\nCreate a data set containing only flights between LAX and BOS in 2012.\n\n\nla_bos &lt;- flights |&gt;\n  filter(year == 2012 & ((origin == \"LAX\" & dest == \"BOS\") | \n           (origin == \"BOS\" & dest == \"LAX\"))) \n\n\nla_bos\n\n# Source:   SQL [?? x 21]\n# Database: mysql  [mdsr_public@mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com:NA/airlines]\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n1  2012    10     1      710            710         0     1538           1540\n2  2012    10     1      818            820        -2     1644           1645\n3  2012    10     1      855            844        11     1742           1712\n4  2012    10     1     1219           1210         9     2043           2038\n5  2012    10     1     1302           1300         2     2133           2125\n6  2012    10     1     1436           1445        -9     2331           2309\n# ℹ more rows\n# ℹ 13 more variables: arr_delay &lt;int&gt;, carrier &lt;chr&gt;, tailnum &lt;chr&gt;,\n#   flight &lt;int&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;,\n#   cancelled &lt;int&gt;, diverted &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt;, time_hour &lt;dttm&gt;\n\n\n\nshow_query(la_bos)\n\n&lt;SQL&gt;\nSELECT *\nFROM `flights`\nWHERE (`year` = 2012.0 AND ((`origin` = 'LAX' AND `dest` = 'BOS') OR (`origin` = 'BOS' AND `dest` = 'LAX')))\n\n\nThe WHERE function in SQL acts as filter() did in R; & has been translated to AND, and | has been translated to OR.\nAs might be expected, dbplyr doesn’t translate every R command into SQL. After all, SQL is not a statistical software and doesn’t, for example, have a mechanism for creating data visualizations. To track which R commands are connected to SQL see the dbplyr reference sheet.\nBecause the data set has been subsetted substantially, we could pull it into R to create an R object. Note that now R is aware of the size of the entire data frame (7064 rows and 21 columns). The la_bos object now exists in the R environment and can be explored through the IDE.\n\n\n\n\n\n\n Watch out!\n\n\n\nBe careful with collect(). Don’t use collect() on large dataframes that won’t fit in an R environment.\n\n\n\nla_bos &lt;- la_bos |&gt;\n  collect()\n\nla_bos\n\n# A tibble: 7,064 × 21\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n1  2012    10     1      710            710         0     1538           1540\n2  2012    10     1      818            820        -2     1644           1645\n3  2012    10     1      855            844        11     1742           1712\n4  2012    10     1     1219           1210         9     2043           2038\n5  2012    10     1     1302           1300         2     2133           2125\n6  2012    10     1     1436           1445        -9     2331           2309\n# ℹ 7,058 more rows\n# ℹ 13 more variables: arr_delay &lt;int&gt;, carrier &lt;chr&gt;, tailnum &lt;chr&gt;,\n#   flight &lt;int&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;,\n#   cancelled &lt;int&gt;, diverted &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt;, time_hour &lt;dttm&gt;\n\n\nChapter 3 will explore more SQL queries and using SQL verbs. For now, let’s continue learning about the different ways R can talk to SQL.\nAlways a good idea to terminate the SQL connection when you are done with it.\n\ndbDisconnect(con_air)"
  },
  {
    "objectID": "02-sql-in-R.html#sql-queries-through-the-dbi-package",
    "href": "02-sql-in-R.html#sql-queries-through-the-dbi-package",
    "title": "2  SQL in R",
    "section": "\n2.2 SQL queries through the DBI package",
    "text": "2.2 SQL queries through the DBI package\nUsing R as a wrapper, we can send actual SQL code to query data from the connection. It is okay if you aren’t yet able to write SQL commands from scratch, but try to figure out what the command is asking for. As mentioned above, we will start from scratch to learn SQL commands in Chapter 3.\nStart by setting up the SQL connection in the same way.\n\ncon_air &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  dbname = \"airlines\",\n  host = \"mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com\",\n  user = \"mdsr_public\",\n  password = \"ImhsmflMDSwR\"\n)\n\n\nLook at the first few rows of the flights data.\n\nBecause the flights data is not an R object, we can’t open it in R to explore the variables. If we want to see a small bit of the data, we can SELECT everything (i.e, *) from the flights table but LIMIT the query to only the first eight observations.\nNote that the code in the dbGetQuery() R function is written in SQL not in R.\nA semicolon (;) is typically used to indicate the termination of a SQL statement. They are not always required (particularly when only one statement is being sent), however, it is good practice to use a semicolon at the end of each SQL statement. (Indeed, some SQL dialects require the semicolon at the end of every statement, regardless of whether or not there are more statements following.)\n\nDBI::dbGetQuery(con_air,\n                \"SELECT * FROM flights LIMIT 8;\")\n\n  year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n1 2010    10   1        1           2100       181      159           2320\n2 2010    10   1        1           1920       281      230           2214\n3 2010    10   1        3           2355         8      339            334\n4 2010    10   1        5           2200       125       41           2249\n5 2010    10   1        7           2245        82      104           2347\n6 2010    10   1        7             10        -3      451            500\n7 2010    10   1        7           2150       137      139           2337\n8 2010    10   1        8             15        -7      538            537\n  arr_delay carrier tailnum flight origin dest air_time distance cancelled\n1       159      XE  N11137   2558    EWR  OMA      162     1133         0\n2       256      B6  N659JB    562    FLL  SWF      131     1119         0\n3         5      B6  N563JB    701    JFK  SJU      196     1597         0\n4       112      XE  N16559   5982    IAD  BNA       82      542         0\n5        77      OO  N908SW   6433    LAX  FAT       37      209         0\n6        -9      AA  N3FRAA    700    LAX  DFW      150     1235         0\n7       122      DL  N347NW   1752    ATL  IAD       70      533         0\n8         1      CO  N73283   1740    SMF  IAH      193     1609         0\n  diverted hour minute           time_hour\n1        0   21      0 2010-10-01 21:00:00\n2        0   19     20 2010-10-01 19:20:00\n3        0   23     55 2010-10-01 23:55:00\n4        0   22      0 2010-10-01 22:00:00\n5        0   22     45 2010-10-01 22:45:00\n6        0    0     10 2010-10-01 00:10:00\n7        0   21     50 2010-10-01 21:50:00\n8        0    0     15 2010-10-01 00:15:00\n\n\n\nHow many flights per year are in the flights table?\n\n\ndbGetQuery(con_air, \n  \"SELECT year, count(*) AS num_flights FROM flights GROUP BY year ORDER BY num_flights;\")\n\n  year num_flights\n1 2016     5617658\n2 2017     5674621\n3 2015     5819079\n4 2014     5819811\n5 2011     6085281\n6 2012     6096762\n7 2013     6369482\n8 2010     6450117\n\n\nNote that we’ve now SELECTed two variables: year and num_flights (which we created along the way using count(*) which is written as n() in R) FROM the flights table. Then we GROUP BY the year variable which retroactively acts on the count(*) function. And last, we ORDER BY (which is similar to arrange()) the new num_flights variable.\nAlways a good idea to terminate the SQL connection when you are done with it.\n\ndbDisconnect(con_air)"
  },
  {
    "objectID": "02-sql-in-R.html#direct-sql-queries-through-a-sql-chunk",
    "href": "02-sql-in-R.html#direct-sql-queries-through-a-sql-chunk",
    "title": "2  SQL in R",
    "section": "\n2.3 Direct SQL queries through a sql chunk",
    "text": "2.3 Direct SQL queries through a sql chunk\nNotice that the formatting of the next few chunks is slightly different. Instead of reporting only the inside / code of the chunk, the entire chunk is printed. The SQL chunks are given by {sql} instead of {r} and each SQL chunk is required to connect to a particular database (through the con_air connection).\nThe same queries have been run.\nStart by setting up the SQL connection in the same way.\n\n```{r}\ncon_air &lt;- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  dbname = \"airlines\",\n  host = \"mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com\",\n  user = \"mdsr_public\",\n  password = \"ImhsmflMDSwR\"\n)\n```\n\n\n```{sql}\n#| connection: con_air\n\nSELECT * FROM flights LIMIT 8;\n```\n\n\n\n\n8 records\n\n\n\nyear\n\n\nmonth\n\n\nday\n\n\ndep_time\n\n\nsched_dep_time\n\n\ndep_delay\n\n\narr_time\n\n\nsched_arr_time\n\n\narr_delay\n\n\ncarrier\n\n\ntailnum\n\n\nflight\n\n\norigin\n\n\ndest\n\n\nair_time\n\n\ndistance\n\n\ncancelled\n\n\ndiverted\n\n\nhour\n\n\nminute\n\n\ntime_hour\n\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n1\n\n\n2100\n\n\n181\n\n\n159\n\n\n2320\n\n\n159\n\n\nXE\n\n\nN11137\n\n\n2558\n\n\nEWR\n\n\nOMA\n\n\n162\n\n\n1133\n\n\n0\n\n\n0\n\n\n21\n\n\n0\n\n\n2010-10-01 21:00:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n1\n\n\n1920\n\n\n281\n\n\n230\n\n\n2214\n\n\n256\n\n\nB6\n\n\nN659JB\n\n\n562\n\n\nFLL\n\n\nSWF\n\n\n131\n\n\n1119\n\n\n0\n\n\n0\n\n\n19\n\n\n20\n\n\n2010-10-01 19:20:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n3\n\n\n2355\n\n\n8\n\n\n339\n\n\n334\n\n\n5\n\n\nB6\n\n\nN563JB\n\n\n701\n\n\nJFK\n\n\nSJU\n\n\n196\n\n\n1597\n\n\n0\n\n\n0\n\n\n23\n\n\n55\n\n\n2010-10-01 23:55:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n5\n\n\n2200\n\n\n125\n\n\n41\n\n\n2249\n\n\n112\n\n\nXE\n\n\nN16559\n\n\n5982\n\n\nIAD\n\n\nBNA\n\n\n82\n\n\n542\n\n\n0\n\n\n0\n\n\n22\n\n\n0\n\n\n2010-10-01 22:00:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n7\n\n\n2245\n\n\n82\n\n\n104\n\n\n2347\n\n\n77\n\n\nOO\n\n\nN908SW\n\n\n6433\n\n\nLAX\n\n\nFAT\n\n\n37\n\n\n209\n\n\n0\n\n\n0\n\n\n22\n\n\n45\n\n\n2010-10-01 22:45:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n7\n\n\n10\n\n\n-3\n\n\n451\n\n\n500\n\n\n-9\n\n\nAA\n\n\nN3FRAA\n\n\n700\n\n\nLAX\n\n\nDFW\n\n\n150\n\n\n1235\n\n\n0\n\n\n0\n\n\n0\n\n\n10\n\n\n2010-10-01 00:10:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n7\n\n\n2150\n\n\n137\n\n\n139\n\n\n2337\n\n\n122\n\n\nDL\n\n\nN347NW\n\n\n1752\n\n\nATL\n\n\nIAD\n\n\n70\n\n\n533\n\n\n0\n\n\n0\n\n\n21\n\n\n50\n\n\n2010-10-01 21:50:00\n\n\n\n\n2010\n\n\n10\n\n\n1\n\n\n8\n\n\n15\n\n\n-7\n\n\n538\n\n\n537\n\n\n1\n\n\nCO\n\n\nN73283\n\n\n1740\n\n\nSMF\n\n\nIAH\n\n\n193\n\n\n1609\n\n\n0\n\n\n0\n\n\n0\n\n\n15\n\n\n2010-10-01 00:15:00\n\n\n\n\n\n\n\n```{sql}\n#| connection: con_air\n\nSELECT year, count(*) AS num_flights FROM flights GROUP BY year ORDER BY num_flights;\n```\n\n\n\n\n8 records\n\n\n\nyear\n\n\nnum_flights\n\n\n\n\n\n2016\n\n\n5617658\n\n\n\n\n2017\n\n\n5674621\n\n\n\n\n2015\n\n\n5819079\n\n\n\n\n2014\n\n\n5819811\n\n\n\n\n2011\n\n\n6085281\n\n\n\n\n2012\n\n\n6096762\n\n\n\n\n2013\n\n\n6369482\n\n\n\n\n2010\n\n\n6450117\n\n\n\n\n\n\nAlways a good idea to terminate the SQL connection when you are done with it.\n\ndbDisconnect(con_air)"
  },
  {
    "objectID": "02-sql-in-R.html#fa-triangle-exclamation-be-aware",
    "href": "02-sql-in-R.html#fa-triangle-exclamation-be-aware",
    "title": "2  SQL in R",
    "section": "\n2.2 Be aware",
    "text": "2.2 Be aware\nBe careful with collect()! Don’t use collect() on large dataframes that won’t fit in an R environment. :::\n\nla_bos &lt;- la_bos |&gt;\n  collect()\n\nla_bos\n\n# A tibble: 7,064 × 21\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n1  2012    10     1      710            710         0     1538           1540\n2  2012    10     1      818            820        -2     1644           1645\n3  2012    10     1      855            844        11     1742           1712\n4  2012    10     1     1219           1210         9     2043           2038\n5  2012    10     1     1302           1300         2     2133           2125\n6  2012    10     1     1436           1445        -9     2331           2309\n# ℹ 7,058 more rows\n# ℹ 13 more variables: arr_delay &lt;int&gt;, carrier &lt;chr&gt;, tailnum &lt;chr&gt;,\n#   flight &lt;int&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;,\n#   cancelled &lt;int&gt;, diverted &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt;, time_hour &lt;dttm&gt;\n\n\n?sec-sql-verbs will explore more SQL queries and using SQL verbs. For now, let’s continue learning about the different ways R can talk to SQL."
  },
  {
    "objectID": "02-sql-in-R.html#be-aware",
    "href": "02-sql-in-R.html#be-aware",
    "title": "2  SQL in R",
    "section": "\n2.2 Be aware",
    "text": "2.2 Be aware\n Be careful with collect()! Don’t use collect() on large dataframes that won’t fit in an R environment. :::\n\nla_bos &lt;- la_bos |&gt;\n  collect()\n\nla_bos\n\n# A tibble: 7,064 × 21\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n1  2012    10     1      710            710         0     1538           1540\n2  2012    10     1      818            820        -2     1644           1645\n3  2012    10     1      855            844        11     1742           1712\n4  2012    10     1     1219           1210         9     2043           2038\n5  2012    10     1     1302           1300         2     2133           2125\n6  2012    10     1     1436           1445        -9     2331           2309\n# ℹ 7,058 more rows\n# ℹ 13 more variables: arr_delay &lt;int&gt;, carrier &lt;chr&gt;, tailnum &lt;chr&gt;,\n#   flight &lt;int&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;int&gt;, distance &lt;int&gt;,\n#   cancelled &lt;int&gt;, diverted &lt;int&gt;, hour &lt;int&gt;, minute &lt;int&gt;, time_hour &lt;dttm&gt;\n\n\n?sec-sql-verbs will explore more SQL queries and using SQL verbs. For now, let’s continue learning about the different ways R can talk to SQL."
  },
  {
    "objectID": "03-sql-verbs.html",
    "href": "03-sql-verbs.html",
    "title": "3  SQL verbs",
    "section": "",
    "text": "class(dbGetQuery(con, \"SHOW TABLES\"))\n\n\ndbGetQuery(con, \"SHOW TABLES\")\n\nThe EXPLAIN command describes the ten field names (variables) in the PI_Info table.\n\ndbGetQuery(con, \"EXPLAIN flights\")\n\n\nMeasurements &lt;- tbl(con, \"Measurements\")\nclass(Measurements)\nPI_Info &lt;- tbl(con, \"PI_Info\")\nSubject &lt;- tbl(con, \"Subjects\")\n\nAlways a good idea to terminate the SQL connection.\n\ndbDisconnect(con)"
  },
  {
    "objectID": "06-const-change-db.html#quarto",
    "href": "06-const-change-db.html#quarto",
    "title": "\n6  Untitled\n",
    "section": "\n6.1 Quarto",
    "text": "6.1 Quarto\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "06-const-change-db.html#running-code",
    "href": "06-const-change-db.html#running-code",
    "title": "\n6  Untitled\n",
    "section": "\n6.2 Running Code",
    "text": "6.2 Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "03-sql-verbs.html#looking-at-the-tables-in-the-database",
    "href": "03-sql-verbs.html#looking-at-the-tables-in-the-database",
    "title": "3  SQL verbs",
    "section": "\n3.1 Looking at the tables in the database",
    "text": "3.1 Looking at the tables in the database\nConsider a database which is based on the Stanford Open Policing Database.\n\n\ncon_traffic &lt;- DBI::dbConnect(\n    RMariaDB::MariaDB(),\n    dbname = \"traffic\",\n    host = \"traffic.st47s.com\", \n    user = \"student\",\n    password = Sys.getenv(\"SQL_LOADING\")\n)\n\nThere are 88 tables in the traffic database. Each table is traffic stop data from a particular city or a given state’s highway patrol.\n\nSHOW TABLES;\n\n\n\n\nDisplaying records 1 - 10\n\n\n\nTables_in_traffic\n\n\n\n\n\nar_little_rock_2020_04_01\n\n\n\n\naz_gilbert_2020_04_01\n\n\n\n\naz_mesa_2023_01_26\n\n\n\n\naz_statewide_2020_04_01\n\n\n\n\nca_anaheim_2020_04_01\n\n\n\n\nca_bakersfield_2020_04_01\n\n\n\n\nca_long_beach_2020_04_01\n\n\n\n\nca_los_angeles_2020_04_01\n\n\n\n\nca_oakland_2020_04_01\n\n\n\n\nca_san_bernardino_2020_04_01\n\n\n\n\n\n\nThe EXPLAIN command describes the 24 field names (variables) in the ma_statewide_2020_04_01 table. Some of the variables are characters (text) and some are numeric (either double or bigint)\n\nEXPLAIN ma_statewide_2020_04_01;\n\n\n\n\nDisplaying records 1 - 10\n\n\n\nField\n\n\nType\n\n\nNull\n\n\nKey\n\n\nDefault\n\n\nExtra\n\n\n\n\n\nraw_row_number\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\ndate\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\nlocation\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\ncounty_name\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\nsubject_age\n\n\nbigint(20)\n\n\nYES\n\n\n\n\n\n\n\n\n\n\nsubject_race\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\nsubject_sex\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\ntype\n\n\ntext\n\n\nYES\n\n\n\n\n\n\n\n\n\n\narrest_made\n\n\ndouble\n\n\nYES\n\n\n\n\n\n\n\n\n\n\ncitation_issued\n\n\ndouble\n\n\nYES"
  },
  {
    "objectID": "03-sql-verbs.html#select-from",
    "href": "03-sql-verbs.html#select-from",
    "title": "3  SQL verbs",
    "section": "\n3.2 SELECT … FROM",
    "text": "3.2 SELECT … FROM\n\nR function: select()\n\n\nSELECT * FROM ma_statewide_2020_04_01 LIMIT 14;\n\n\n\n\nDisplaying records 1 - 10\n\n\n\nraw_row_number\n\n\ndate\n\n\nlocation\n\n\ncounty_name\n\n\nsubject_age\n\n\nsubject_race\n\n\nsubject_sex\n\n\ntype\n\n\narrest_made\n\n\ncitation_issued\n\n\nwarning_issued\n\n\noutcome\n\n\ncontraband_found\n\n\ncontraband_drugs\n\n\ncontraband_weapons\n\n\ncontraband_alcohol\n\n\ncontraband_other\n\n\nfrisk_performed\n\n\nsearch_conducted\n\n\nsearch_basis\n\n\nreason_for_stop\n\n\nvehicle_type\n\n\nvehicle_registration_state\n\n\nraw_Race\n\n\n\n\n\n1\n\n\n2007-06-06\n\n\nMIDDLEBOROUGH\n\n\nPlymouth County\n\n\n33\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\nSpeed\n\n\nPassenger\n\n\nMA\n\n\nWhite\n\n\n\n\n2\n\n\n2007-06-07\n\n\nSEEKONK\n\n\nBristol County\n\n\n36\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n0\n\n\n1\n\n\nwarning\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\nother\n\n\n\n\nCommercial\n\n\nMA\n\n\nWhite\n\n\n\n\n3\n\n\n2007-06-07\n\n\nMEDFORD\n\n\nMiddlesex County\n\n\n56\n\n\nwhite\n\n\nfemale\n\n\nvehicular\n\n\n0\n\n\n0\n\n\n1\n\n\nwarning\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nPassenger\n\n\nMA\n\n\nWhite\n\n\n\n\n4\n\n\n2007-06-07\n\n\nMEDFORD\n\n\nMiddlesex County\n\n\n37\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n0\n\n\n1\n\n\nwarning\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nCommercial\n\n\nMA\n\n\nWhite\n\n\n\n\n5\n\n\n2007-06-07\n\n\nEVERETT\n\n\nMiddlesex County\n\n\n22\n\n\nhispanic\n\n\nfemale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nCommercial\n\n\nMA\n\n\nHispanic\n\n\n\n\n6\n\n\n2007-06-07\n\n\nMEDFORD\n\n\nMiddlesex County\n\n\n34\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\nSpeed\n\n\nCommercial\n\n\nMA\n\n\nWhite\n\n\n\n\n7\n\n\n2007-06-07\n\n\nSOMERVILLE\n\n\nMiddlesex County\n\n\n54\n\n\nhispanic\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nCommercial\n\n\nMA\n\n\nHispanic\n\n\n\n\n8\n\n\n2007-06-07\n\n\nHOPKINTON\n\n\nMiddlesex County\n\n\n31\n\n\nhispanic\n\n\nfemale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nPassenger\n\n\nMA\n\n\nHispanic\n\n\n\n\n9\n\n\n2007-06-07\n\n\nSOMERVILLE\n\n\nMiddlesex County\n\n\n21\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\nPassenger\n\n\nMA\n\n\nWhite\n\n\n\n\n10\n\n\n2007-06-06\n\n\nBARNSTABLE\n\n\nBarnstable County\n\n\n56\n\n\nwhite\n\n\nmale\n\n\nvehicular\n\n\n0\n\n\n1\n\n\n0\n\n\ncitation\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\nSpeed\n\n\nPassenger\n\n\nMA\n\n\nWhite"
  },
  {
    "objectID": "03-sql-verbs.html#where",
    "href": "03-sql-verbs.html#where",
    "title": "3  SQL verbs",
    "section": "\n3.3 WHERE",
    "text": "3.3 WHERE\n\nR function: filter()\n\nWHERE operates on the original data in the table and HAVING operates on the result set."
  },
  {
    "objectID": "03-sql-verbs.html#group-by",
    "href": "03-sql-verbs.html#group-by",
    "title": "3  SQL verbs",
    "section": "\n3.4 GROUP BY",
    "text": "3.4 GROUP BY\n\nR function: group_by()"
  },
  {
    "objectID": "03-sql-verbs.html#order-by",
    "href": "03-sql-verbs.html#order-by",
    "title": "3  SQL verbs",
    "section": "\n3.5 ORDER BY",
    "text": "3.5 ORDER BY\n\nR function: arrange()"
  },
  {
    "objectID": "03-sql-verbs.html#having",
    "href": "03-sql-verbs.html#having",
    "title": "3  SQL verbs",
    "section": "\n3.6 HAVING",
    "text": "3.6 HAVING\n\nR function: filter()\n\nWHERE operates on the original data in the table and HAVING operates on the result set."
  },
  {
    "objectID": "03-sql-verbs.html#limit",
    "href": "03-sql-verbs.html#limit",
    "title": "3  SQL verbs",
    "section": "\n3.7 LIMIT",
    "text": "3.7 LIMIT\n\nR function: head()"
  }
]